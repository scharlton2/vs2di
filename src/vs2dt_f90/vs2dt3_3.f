      Program Main
      Integer JSTOP
      character*80 filen
      filen = 'vs2dt.fil'
      JSTOP = 0
C     SET UP TO READ FROM DATA FILE GENERATED BY VS2DTI
      call SETUP(0, 0, 0, filen)
 10   CALL STEP(JSTOP)
      IF (JSTOP.EQ.0) GOTO 10
      stop
      end

      include 'd_modules.inc'
      SUBROUTINE SETUP(iold, ihydr, isorp, filen)
C *** THIS SUBROUTINE IS THE FIRST HALF OF THE ORIGINAL MAIN CODE
C *** THAT READS THE SIMULATION DATA
C ***    12/1/98
C
C
C
C******
CVSEXEC
C******
C -----------------------------------------------------------------
C         ************ PROGRAM VS2DT *********************
C
C   PROGRAM TO SOLVE FOR:
C      TWO DIMENSIONAL VERTICAL SECTION OR CYLINDRICAL THREE
C          DIMENSIONAL FLUID FLOW AND SOLUTE TRANSPORT UNDER
C          VARIABLY SATURATED CONDITIONS
C
C       FLUID FLOW IS SOLVED FOR BY AN IMPLICIT FINITE DIFFERENCE
C          FORMULATION OF THE COMBINED RICHARDS AND COOPER-JACOB
C          EQUATIONS FOR FLUID CONTINUITY.
C
C   -------      VERSION 3.3  April 2012        ----------
C .................................................................
C
C          DEFINITION OF FUNCTIONAL RELATIONSHIPS REQUIRED
C  VSHKU = RELATIVE HYDRAULIC CONDUCTIVITY AS A FUNCTION OF
C             PRESSURE HEAD
C  VSTHU = VOLUMETRIC MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C  VSDTHU = FIRST DERIVATIVE OF MOISTURE CONTENT WITH RESPECT
C              TO PRESSURE HEAD
C  VSTHNV = PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC MOISTURE
C              CONTENT
C  VSRDF = ROOT ACTIVITY AS A FUNCTION OF TIME AND DEPTH
C  VTRET = BULK DENSITY TIMES SLOPE OF ADSORPTION ISOTHERM.
C
C-----------------------------------------------------------
C
C      SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_hcon.inc'
      include 'd_equat.inc'
      include 'd_jtxx.inc'
      include 'd_dumm.inc'
      include 'd_ptet.inc'
      include 'd_trxx.inc'
      include 'd_trxy1.inc'
      include 'd_pit.inc'
      include 'd_sip.inc'
      include 'd_plott.inc'
      include 'd_spfc.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_hcon.inc'
c      include 'c_equat.inc'
c      include 'c_jtxx.inc'
c      include 'c_dumm.inc'
c      include 'c_ptet.inc'
c      include 'c_trxx.inc'
c      include 'c_trxy1.inc'
c      include 'c_pit.inc'
c      include 'c_sip.inc'
c      include 'c_plott.inc'
c      include 'c_spfc.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/PND/POND
      COMMON/WGT/WUS,WDS
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      CHARACTER*80 TITL,filen,f5,f6,f7,f8,f9,f10,f11,f12,blank
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      COMMON/MASSB/ BL(72),bcmft,bcmtt,bl29I,bl29IT,bl29O,bl29OT,
     1bl68I,bl68IT,bl68o,bl68OT,bl66T
      integer hydraulicFunctionType, adsorptionType, iuHead, 
     &iuConcentration
      common/functiontype/ hydraulicFunctionType, adsorptionType
      COMMON/VERSION/VER2P5
      LOGICAL VER2P5
      common/iuNumber/ iuHead, iuConcentration
C *** NEXT STATEMENT CHANGED FROM SAVE TO COMMON
      COMMON/TTT/IFET,IFET1,NITT,NITT1
      common/elimit/elimit1,elimit2
      real*8 ang
      include 'd_kdum.inc'
c      include 'c_kdum.inc'
c *** Set version, hydraulic function type, and sorption type
c
      elimit1 = 1.0d-90
      elimit2 = 0.0d0
      if (iold.eq.1) then
          VER2P5 = .true.
          hydraulicFunctionType = ihydr
        adsorptionType = isorp
      else
        VER2P5 = .false.
      endif
c
c   open files 
c
      iuHead = 5
      iuConcentration = 5
      GRAV = .FALSE.
      blank = ' '
      open(12,file='fort.12',FORM='UNFORMATTED',ACTION='WRITE', 
     `POSITION='REWIND')
      open(2,file=filen)
      read(2,9090)f5
      read(2,9090)f6
      read(2,9090)f7
      read(2,9090)f8
      read(2,9090)f9
      read(2,9090)f11
      read(2,9090,end=9088)f10
      iInitial = index(f10,'#')
      if (iInitial.ne.0) go to 9088
      if(f5.ne.f10.and.f10.ne.blank) then
       open(13,file='fort.13',FORM='UNFORMATTED')
       open(10,file=f10)
c       iuHead = 10
      end if
      read(2,9090,end=9089)f12
c      iInitial = index(f12,'#')
c      if (iInitial.ne.0) then
c       f12 = f10
c       iuConcentration = iuHead
c       go to 9088
c      end if
 9089 continue
c      if(f12.eq.blank) f12 = f10
c      if(f5.ne.f12.and.f12.ne.blank) then
c       if(f10.ne.f12) then
c        open(12,file=f12,FORM='UNFORMATTED')
c        iuConcentration = 12
c       else
c        iuConcentration = 10
c       end if
c      end if
c      read(2,9090)f13
c      open(13,file=f13)
 9088 open(5,file=f5)
      open(6,file=f6)
      open(7,file=f7)
      open(8,file=f8)
      open(9,file=f9)
      open(11,file=f11)
 9090 format(a80)
C
C-------------------------------------------------------------------
C
C  ---- READ AND WRITE PROBLEM TITLE AND SPACE AND TIME CONSTANTS
C
      JSTOP=0
      READ (05,4000) TITL
      READ (5,*) TMAX,STIM,ANG
      READ (05,4010) ZUNIT,TUNIT,CUNX
      READ (05,*) NXR,NLY
      READ (05,*) NRECH,NUMT
c
c  o13p triggers high precisions output
c  o12p triggers p,c unformatted output to file 12
c  o9p = t for MB output only at specified times
c  o11p = t for obsPoint output only at specified times
c
      if(NUMT.lt.0) then
       numt = -numt
       o13p = .TRUE.
      else
       o13p = .FALSE.
      end if
      if (nrech.lt.0) then
       nrech = -nrech
       o12p = .TRUE.
      else
       o12p = .FALSE.
      end if
      WRITE (06,4060)
      WRITE (06,4070) TITL,TMAX,TUNIT,STIM,NRECH,NUMT,NLY,NXR
      WRITE(06,4080) ANG
      IF(ANG.GT.90.0D0.OR.ANG.LT.-90.0D0)THEN
      WRITE(06,4090)
      jstop=2
      return
      END IF
      READ (05,*) RAD,ITSTOP,TRANS
      IF(TRANS) READ(05,*)CIS,CIT,SORP
      READ (05,*) F11P,F7P,F8P,F9P,F6P
      READ (05,*) THPT,SPNT,PPNT,HPNT,VPNT
      WRITE (06,4100) F8P,ITSTOP,F7P,F11P,F9P,F6P
      WRITE (06,4110) THPT,SPNT,PPNT,HPNT,VPNT
      NLYY=NLY-1
      NXRR=NXR-1
      NNODES=NLY*NXR
      include 'd_arrays.inc'
c      include 'c_arrays.inc'
C *** SET ALL ARRAYS TO ZERO
      DO 710 I=1, NLY
      DELZ(I) = 0.0D0
      DZZ(I) = 0.0D0
 710  CONTINUE
      DO 715 I=1, NXR
      DXR(I) = 0.0D0
      RX(I) = 0.0D0
 715  CONTINUE
      DO 711 I=1, NNODES
      HX(I) = 0.0D0
      NTYP(I) = 0
      THETA(I) = 0.0D0
      THLST(I) = 0.0D0
      P(I) = 0.0D0
      PXXX(I) = 0.0D0
      Q(I) = 0.0D0
      QQ(I) = 0.0D0
      HCND(I) = 0.0D0
      HKLL(I) = 0.0D0
      HKTT(I) = 0.0D0
      A(I) = 0.0D0
      B(I) = 0.0D0
      C(I) = 0.0D0
      D(I) = 0.0D0
      E(I) = 0.0D0
      RHS(I) = 0.0D0
      XI(I) = 0.0D0
      JTEX(I) = 0
      DUM(I) = 0.0D0
      DPTH(I) = 0.0D0
      RT(I) = 0.0D0
      DX1(I) = 0.0D0
      DX2(I) = 0.0D0
      DZ1(I) = 0.0D0
      DZ2(I) = 0.0D0
      VX(I) = 0.0D0
      VZ(I) = 0.0D0
      CC(I) = 0.0D0
      COLD(I) = 0.0D0
      CS(I) = 0.0D0
      QT(I) = 0.0D0
      NCTYP(I) = 0
      RET(I) = 0.0D0
      AO(I) = 0.0D0
      BO(I) = 0.0D0
      CO(I) = 0.0D0
      DO(I) = 0.0D0
      EO(I) = 0.0D0
      PITT(I) = 0.0D0
 711  CONTINUE
      DO 712 I=1,72
      BL(I)=0.0D0
 712  CONTINUE
      bcmft = 0.0D0
      bcmtt = 0.0D0
      bl29I = 0.0D0
      bl29IT = 0.0D0
      bl29O = 0.0D0
      bl29OT = 0.0D0
      bl68I = 0.0D0
      bl68IT = 0.0D0
      bl68O = 0.0D0
      bl68OT = 0.0D0
      bl66T = 0.0D0
C
C   ESTABLISH HORIZONTAL OR RADIAL SPACING
C
      READ (05,*) IFAC,FACX
      IF(IFAC.GT.0) GO TO 20
C
C   READ IN SPACING FOR EACH COLUMN
C
      READ (05,*) (DXR(K),K=1,NXR)
      DO 10 K=1,NXR
   10 DXR(K)=DXR(K)*FACX
      GO TO 60
   20 IF(IFAC.EQ.2) GO TO 40
      DO 30 K=1,NXR
   30 DXR(K)=FACX
      GO TO 60
C
C  IF IFAC=2, HORIZONTAL NODE SPACING IS INCREMENTED BY A CONSTANT
C    MULTIPLIER UNTIL A USER-SPECIFIED MAXIMUM IS REACHED, WHERE-
C    UPON THE SPACING BECOMES CONSTANT
C
   40 READ (05,*) XMULT,XMAX
      DXR(1)=FACX
      DXR(2)=FACX
      DO 50 K=3,NXRR
      DXR(K)=DXR(K-1)*XMULT
      IF(DXR(K) .GT. XMAX)DXR(K)=XMAX
   50 CONTINUE
      DXR(NXR)=DXR(NXRR)
C
C   ESTABLISH VERTICAL SPACING
C
   60 READ (05,*) JFAC,FACZ
      IF(JFAC.GT.0) GO TO 80
C
C   READ IN VERTICAL SPACINGS INDIVIDUALLY
C
      READ (05,*) (DELZ(K),K=1,NLY)
      DO 70 K=1,NLY
   70 DELZ(K)=DELZ(K)*FACZ
      GO TO 120
   80 IF(JFAC.EQ.2) GO TO 100
      DO 90 K=1,NLY
   90 DELZ(K)=FACZ
      GO TO 120
C
C   ESTABLISH VERTICAL SPACING BY PROGRESSION, AS ABOVE FOR HORIZ.
C
  100 READ (05,*) ZMULT,ZMAX
      DELZ(1)=FACZ
      DELZ(2)=FACZ
      DO 110 K=3,NLYY
      DELZ(K)=DELZ(K-1)*ZMULT
      IF(DELZ(K) .GT. ZMAX)DELZ(K)=ZMAX
  110 CONTINUE
      DELZ(NLY)=DELZ(NLYY)
  120 CONTINUE
C
C     DETERMINE HORIZONTAL AND VERTICAL COORDINATES
C
      RX(1)=-0.5D0 *DXR(1)
      DO 130 N=2,NXR
      RX(N)=RX(N-1)+0.5D0 *(DXR(N-1)+DXR(N))
  130 CONTINUE
      DZZ(1)=-0.5D0 *DELZ(1)
      DO 140 J=2,NLY
  140 DZZ(J)=DZZ(J-1)+0.5D0 *(DELZ(J-1)+DELZ(J))
      WRITE (06,4120) ZUNIT,(DELZ(K),K=1,NLY)
      WRITE (06,4130) ZUNIT,(DXR(K),K=1,NXR)
      PI=3.141592654D0
      PI2=PI+PI
      ANG=ANG/360.0D0
      IF(ANG.EQ.0.0D0) THEN
      CS1=1.0D0
      CS2=0.0D0
      ELSE
      IF(ANG.EQ.0.25D0.OR.ANG.EQ.-0.25D0) THEN
      CS1=0.0D0
      ELSE
      CS1=DCOS(ANG*PI2)
      END IF
      CS2=-DSIN(ANG*PI2)
      END IF
C
C    READ DATA FOR MONITORING TIMES AND POINTS
C
      NPLT=0
      o9p = .false.
      o11p = o9p
      IF(F8P) THEN
      READ (05,*) NPLT
      include 'd_obst.inc'
c      include 'c_obst.inc'
      IF(NPLT.EQ.0)NPLT=1
      READ (05,*) (PLTIM(K),K=1,NPLT)
      WRITE (06,4140) (PLTIM(K),K=1,NPLT)
      else
      include 'd_obst.inc'
      END IF
      IF(F11P) THEN
      READ (05,*) NOBS
      if (nobs.lt.0) then
       nobs = -nobs
       o11p = .true.
      end if
      include 'd_obsp.inc'
      READ (05,*) ((KDUM(K,J),J=1,2),K=1,NOBS)
      WRITE (06,4150) ((KDUM(K,J),J=1,2),K=1,NOBS)
c      include 'c_obsp.inc'
      DO 150 K=1,NOBS
      N=NLY*(KDUM(K,2)-1)+KDUM(K,1)
      IJOBS(K)=N
  150 continue
      END IF
      IF (F9P) THEN
      READ(05,*)NMB9
      if (nmb9.lt.0) then
       nmb9 = -nmb9
       o9p = .true.
      end if
      if (nmb9.gt.72) nmb9 = 72
      READ(05,*) (MB9(K),K=1,NMB9)
      WRITE(06,4160) (MB9(K),K=1,NMB9)
      END IF
      PLTIM(NPLT+1)=TMAX+TMAX
      IF(RAD) THEN
      WRITE(06,4050)
      ELSE
      WRITE (06,4040)
      END IF
      IF(TRANS) THEN
      WRITE(06,4240)
      IF(CIS) THEN
      WRITE(6,4200)
      ELSE
      WRITE(6,4210)
      END IF
      IF(CIT) THEN
      WRITE(6,4220)
      ELSE
      WRITE(6,4230)
      END IF
      IF(SORP) WRITE(06,4250)
      END IF
      IF(F11P) then
       if (o13p) then
        if(trans) then
         WRITE (11,4033) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
        else
         WRITE (11,4031) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
        end if
       else
        if(trans) then
         WRITE (11,4032) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
        else
         WRITE (11,4030) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
        end if
       end if
      end if
C
C     INITIALIZE CONSTANTS
C
      ITEST=0
      KTIM=0
      NITT=0
      NITT1=0
      JFLAG=1
      KP=0
      jplt = 0
      WRITE (06,4170)
C
C
C   READ AND WRITE INITIAL VALUES OF PRESSURE HEAD, TOTAL HEAD,
C    THETA, AND SATURATION
C -------------------------------------------------------------
C
      CALL VSREAD
      CALL VSSIP
      IFET=0
      IFET2=0
      CALL VSOUTP
      include 'd_kdumDealloc.inc'
      RETURN
 4000 FORMAT(A80)
 4010 FORMAT(4A4)
 4020 FORMAT(5X,20(1H*),1X,31HDIMENSIONS TOO LARGE FOR ARRAYS,
     &1X,20(1H*)/5X,6HNLY = ,I6,2X,6H,NXR = ,I6)
 4030 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A4,2X,
     &5x,'NODE',3x,
     &  6H XR,  ,A4,3X,6H Z,    ,A4,3X,6H H,   ,A4,3X,6H  P,  ,A4,
     & 3X,6H THETA,5X,8H     SAT,5x,'      VX',5x,'      VZ'
     &5x,'      ET')
 4031 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A4,6X,
     &  'NODE',15x, 
     &  6H XR,  ,A4,10X,6H Z,    ,A4,10X,6H H,   ,A4,10X,6H  P,  ,A4,
     & 12X,6H THETA,12X,8H     SAT,12x,'      VX',12x,'      VZ',
     & 12x,'      ET')
 4032 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A4,2X,
     &5x,'NODE',3x,
     &  6H XR,  ,A4,3X,6H Z,    ,A4,3X,6H H,   ,A4,3X,6H  P,  ,A4,
     & 3X,6H THETA,5X,8H     SAT,10x,'CONC',5x,'      VX',5x,
     &'      VZ', 5x,'      ET')
 4033 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A4,6X,
     & 'NODE',15x,
     &  6H XR,  ,A4,10X,6H Z,    ,A4,10X,6H H,   ,A4,10X,6H  P,  ,A4,
     & 12X,6H THETA,12X,8H     SAT,17x,'CONC',12x,'      VX',12x,
     & '      VZ',12x,'      ET')
 4040 FORMAT(5X,32HCOORDINATE SYSTEM IS RECTANGULAR)
 4050 FORMAT(5X,27HCOORDINATE SYSTEM IS RADIAL)
 4060 FORMAT(35X,60('+')/35X,'+',26X,6H VS2DT,26X,'+'/35X,
     &'+',23x,' VERSION 3.3',23x,'+'/35x,
     &'+',11X,'SIMULATION OF 2-DIMENSIONAL VARIABLY',11X,'+'/
     &35X,'+',12X,'SATURATED FLOW AND SOLUTE TRANSPORT',11X,'+'
     &/35X,'+',11X,'        THROUGH POROUS MEDIA.       ',11X,'+'
     & /35X,60('+')//)
 4070 FORMAT(//,1X,100(1H*)/5X,A80/1X,100(1H*)//10X,
     &24HSPACE AND TIME CONSTANTS/10X,23(1H-)/
     & 5X,26HMAXIMUM SIMULATION TIME = ,E14.6,1X,A4/
     &5X,'STARTING TIME = ',F10.4,/
     &5X,28HNUMBER OF RECHARGE PERIODS =,I10/
     &4X,32H MAXIMUM NUMBER OF TIME STEPS = ,I10/
     &5X,17HNUMBER OF ROWS = ,I6/5X,20HNUMBER OF COLUMNS = ,I6)
 4080 FORMAT(5X,'AXES TILTED BY ANGLE = ',F8.2)
 4090 FORMAT(1X,'ANGLE OF AXES TILTING MUST BE BETWEEN -90 AND 90 ',
     &'DEGREES',/,1X,'SIMULATION TERMINATED')
 4100 FORMAT(10X,16HSOLUTION OPTIONS/10X,16(1H-)/
     &5X,'WRITE ALL PRESSURE HEADS TO FILE 8',
     &23H AT OBSERVATION TIMES? ,L1,/
     &5X,'STOP SOLUTION IF MAXIMUM NO.',
     &' OF ITERATIONS EXCEEDED IN ANY TIME STEP? ',L1/5X,
     &'WRITE BOUNDARY FLUXES TO FILE 7? ',
     &L1/5X,'WRITE RESULTS AT SELECTED OBSERVATION POINTS TO ',
     &'FILE 11? ', L1/,5X,'WRITE MASS BALANCE RATES TO FILE 9? ',L1/
     &5X,'WRITE MASS BALANCE RATES TO FILE 6? ',L1)
 4110 FORMAT(1H ,4X,35HWRITE MOISTURE CONTENTS TO FILE 6? ,L1/
     & 5X,29HWRITE SATURATIONS TO FILE 6? ,L1/
     & 5X,32HWRITE PRESSURE HEADS TO FILE 6? ,L1/
     & 5X,29HWRITE TOTAL HEADS TO FILE 6? ,L1/
     &5X,'WRITE VELOCITIES TO FILE 6? ',L1)
 4120 FORMAT(50X,39HGRID SPACING IN VERTICAL DIRECTION, IN ,A4/
     & (10(F10.3)))
 4130 FORMAT(50X,47HGRID SPACING IN HORIZONTAL OR RADIAL DIRECTION,
     &,3H IN,1X,A4/(10F10.3))
 4140 FORMAT(5X,43HTIMES AT WHICH H WILL BE WRITTEN TO FILE 08
     &/10(5X,10E12.5,/))
 4150 FORMAT(5X,37HROW AND COLUMN OF OBSERVATION POINTS:/
     & 10(2X,2I5))
 4160 FORMAT(5X,'MASS BALANCE COMPONENTS WRITTEN TO FILE 9',
     &/,5X,24I4)
 4170 FORMAT(5X,36HMATRIX EQUATIONS TO BE SOLVED BY SIP)
 4180 FORMAT(5X,100(1H*)/5X,17HEND OF SIMULATION/
     &   5X,100(1H*))
 4190 FORMAT(5X,'TOTAL NUMBER OF ITERATIONS FOR FLOW EQUATION = ',I6
     &/5X,'TOTAL NUMBER OF ITERATIONS FOR TRANSPORT EQUATION = ',I6)
 4200 FORMAT(5X,'CENTRAL DIFFERENCING IN SPACE USED FOR TRANSPORT',
     &' EQUATION')
 4210 FORMAT(4X,' BACKWARD DIFFERENCING IN SPACE USED FOR TRANSPORT',
     &' EQUATION')
 4220 FORMAT(4X,' CENTRAL DIFFERENCING IN TIME USED FOR TRANSPORT',
     &' EQUATION')
 4230 FORMAT(4X,' BACKWARD DIFFERENCING IN TIME USED FOR TRANSPORT',
     &' EQUATION')
 4240 FORMAT(4X,' TRANSPORT TO BE SIMULATED')
 4250 FORMAT(4X,' NONLINEAR SORPTION TO BE SIMULATED')
      END
      SUBROUTINE STEP(JSTP)
C *** THIS IS THE SECOND HALF OF THE ORIGINAL MAIN CODE. THIS
C *** PERFORMS A SINGLE TIME STEP. THE LOOPING IS DONE IN THE CALLING
C *** PROGRAM. THE SUBROUTINE RETURNS THE SIMULATION TIME, TIME STEP,
C *** AND THE FLAG JSTP. WHEN JSTP EQUALS 1, THIS SIGNIFIES
C *** END OF SIMULATION.
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_hcon.inc'
      include 'd_equat.inc'
      include 'd_jtxx.inc'
      include 'd_dumm.inc'
      include 'd_ptet.inc'
      include 'd_trxx.inc'
      include 'd_trxy1.inc'
      include 'd_plott.inc'
      include 'd_spfc.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_hcon.inc'
c      include 'c_equat.inc'
c      include 'c_jtxx.inc'
c      include 'c_dumm.inc'
c      include 'c_ptet.inc'
c      include 'c_trxx.inc'
c      include 'c_trxy1.inc'
c      include 'c_plott.inc'
c      include 'c_spfc.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/PND/POND
      COMMON/WGT/WUS,WDS
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      CHARACTER*80 TITL,filen,f5,f6,f7,f8,f9,f10,f11
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      integer hydraulicFunctionType, adsorptionType
      common/functiontype/ hydraulicFunctionType, adsorptionType
      COMMON/TTT/IFET,IFET1,NITT,NITT1
C
C -------------------------------------------------------------
C       START OF TIME LOOP
C -------------------------------------------------------------
C
  160 IF(JFLAG.EQ.1)IFET1=1
      IF (JSTOP.GT.1) THEN
         JSTP=JSTOP
         RETURN
      ENDIF
      CALL VSTMER
C
C *** IF NO MORE PERIODS TO SIMULATE, JSTOP IS SET TO 1 IN VSTMER,
C *** WE JUST RETURN AND LET THE CALLING PROGRAM TERMINATE THE
C *** THE EXECUTION
      IF (JSTOP.GT.1) THEN
         JSTP=JSTOP
         RETURN
      ENDIF
C
      TRANS1=.FALSE.
      IF(.NOT.SSTATE) THEN
C
C   SET UP AND SOLVE MATRIX EQUATIONS FOR FLOW
C
  170 CALL VSMGEN
      IF (JSTOP.GT.1) THEN
         JSTP=JSTOP
         RETURN
      ENDIF
C
C   CHECK FOR PONDING DURING THIS TIME STEP
C
      CALL VSPOND(IFET,IFET1,IFET2)
C
C   IF PONDING HAS OCCURRED, EQUATIONS NEED TO BE SOLVED AGAIN
C
      IF(IFET.NE.0) THEN
      IF(NIT.LT.ITMAX) THEN
      DO 50 II=1,NNODES
      IF(NTYP(II).NE.1.AND.HX(II).GT.0.0D0) P(II)=PXXX(II)
   50 CONTINUE
c      nit = 1
      GO TO 170
      ELSE
      WRITE(6,4260)
      END IF
      END IF
C
C   REEVALUATE NONLINEAR COEFFICIENTS
C
      CALL VSCOEF
      NITT=NITT+NIT
      END IF
      IF((TRANS.OR.VPNT).AND..NOT.SSTATE) CALL VTVELO
      IF(TRANS) THEN
      IF(.NOT.SSTATE) THEN
C
C   DETERMINE VELOCITIES AND DISPERSION TENSOR
C
      CALL VTDCOEF
      END IF
      TRANS1=.TRUE.
C
C   SET UP AND SOLVE MATRIX EQUATION FOR TRANSPORT
C
      CALL VTSETUP
      NITT1=NITT1+NIT1
      END IF
C
C   PRINT RESULTS AND COMPUTE MASS BALANCE COMPONENTS
C
      CALL VSOUTP
      CALL VSFLUX
C
C-------------------------------------------------------------------
C     END OF TIME STEP
C-------------------------------------------------------------------
C
C *** ASSIGN VALUES TO SUBROUTINE ARGUMENTS TO RETURN
      JSTP = JSTOP
      RETURN
 4260 FORMAT(5X,'-- WARNING --  INFILTRATION/PONDING BOUNDARY WAS NOT',
     &' SOLVED ACCURATELY FOR THIS TIME STEP')
      END
      SUBROUTINE VSREAD
C******
CVSREAD
C******
C
C   PURPOSE: TO READ INITIAL HEAD AND SATURATION DATA
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_jtxx.inc'
      include 'd_dumm.inc'
      include 'd_ptet.inc'
      include 'd_trxx.inc'
      include 'd_idumm.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      include 'd_equat.inc'
      include 'd_BF.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_jtxx.inc'
c      include 'c_dumm.inc'
c      include 'c_ptet.inc'
c      include 'c_trxx.inc'
c      include 'c_idumm.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/WGT/WUS,WDS
      COMMON/JCON/JSTOP,JFLAG,jflag1
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL PHRD
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/hinterp/ DELP,nprop,I1,I2,I3,I4,I5,I6
      CHARACTER*80 TITL
      CHARACTER*80 IFMT,FREE,UNFORMATTED
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      common/functiontype/ hydraulicFunctionType, adsorptionType
      COMMON/VERSION/VER2P5
      LOGICAL VER2P5
      integer hydraulicFunctionType, adsorptionType, iuHead,
     &iuConcentration
      common/iuNumber/ iuHead,iuConcentration
      include 'd_idummAlloc.inc'
C-----------------------------------------------------------------------
C
C   READ AND WRITE INITIAL DATA FOR SIMULATION
C
      FREE = 'free'
      UNFORMATTED = 'unformatted'
      IF (TRANS) THEN
      READ (5,*) EPS,HMAX,WUS,EPS1
      ELSE
      READ(5,*) EPS,HMAX,WUS
      EPS1=0.0D0
      END IF
      READ (5,*) MINIT,ITMAX
      READ (05,*) PHRD
      IF(TRANS) THEN
      READ (05,*) NTEX,NPROP,NPROP1
      IF (.NOT.VER2P5) READ (05,*) hydraulicFunctionType,adsorptionType
      ELSE
      READ (05,*) NTEX,NPROP
      IF (.NOT.VER2P5) READ (05,*) hydraulicFunctionType
      NPROP1=0
      END IF
c
c  revision for Rossi-Nimmo
c
      if (hydraulicFunctionType.eq.4) nprop = 19
      include 'd_rpropAlloc.inc'
      if (hydraulicFunctionType.eq.4) nprop = 6
c
c  end revision
c
C
C   CHECK THAT SUM OF WEIGHTING FACTORS IS EQUAL TO ONE
C
      WRITE (6,4000) EPS,ZUNIT,EPS1,HMAX
      IF(WUS.EQ.1.0D0) THEN
      WDS=0.0D0
      WRITE(06,4020)
      ELSE
      IF(WUS.EQ.0.5D0) THEN
      WDS=0.5D0
      WRITE(06,4070)
      ELSE
      WUS=0.0D0
      WRITE(06,4010)
      END IF
      END IF
      WRITE (6,4080) NTEX,NPROP,NPROP1,MINIT,ITMAX
      include 'd_sconAlloc.inc'
c      include 'c_sconItmax.inc'
      WRITE (06,4100)
      IF (TRANS) WRITE(06,4110)
C
C   READ AND WRITE MATERIAL PROPERTIES FOR EACH TEXTURAL CLASS
C

      DO 20 J22=1,NTEX
      DO 10 J23=1,NPROP
   10 HK(J22,J23)=0.0D0
      DO 20 J23=1,NPROP1
   20 HT(J22,J23)=0.0D0
      DO 30 J22=1,NTEX
      READ (5,*) J
      READ (5,*) ANIZ(J),(HK(J,I),I=1,NPROP)
      WRITE (6,4120) J,ANIZ(J),(HK(J,I),I=1,NPROP)
      IF(TRANS) THEN
      READ(5,*) (HT(J,I),I=1,NPROP1)
      WRITE(6,4130) (HT(J,I),I=1,NPROP1)
      END IF
c
c  revsion for Rossi-Nimmo
c
c  hk(j,3) = theta_s; hk(j,4) = psi_0; hk(j,5) = psi_d; 
c  hk(j,6) = lambda; hk(j,7) = psi_i; hk(j,8) = c;
c  hk(j,9) = alpha; hk(j,10) = psi_j; hk(j,11) = theta_i;
c  hk(j,12) = theta_j; hk(j,13) = I(theta_s)**2;
c  hk(j,14) = (lambda + 1)/lambda; hk(j,15) = 
c  (theta_j/theta_s)**((lambda+1)/lambda))
c  hk(j,16) = 2sqrt(c)/psi_0; 
c  hk(j,17) = sqrt(1 - theta_i/theta_s)
c  hk(j,18) = I3(theta_j);  hk(j,19) = I2(theta_i)
c
      if(j.ne.1) then
      if (hydraulicFunctionType.eq.4) then
       hk(j,7) = hk(j,4)*(2.0D0/(2.0D0+hk(j,6)))**(-1.0D0/hk(j,6))
       hk(j,8) = .50D0*hk(j,6)*(2.0D0/(2.0D0+hk(j,6)))**((2.0D0+hk(j,6))
     9/hk(j,6))
       hk(j,9) =  hk(j,6)*exp(1.0D0)*(hk(j,4)/hk(j,5))**hk(j,6)
       hk(j,10) = hk(j,5)*exp(-1.0D0/hk(j,6))
       hk(j,11) = VSTHUOT(-hk(j,7),j)
       hk(j,12) = VSTHUOT(-hk(j,10),j)
       hk(j,14) = (hk(j,6) + 1.0D0)/hk(j,6)
       hk(j,15) = (hk(j,12)/hk(j,3))**hk(j,14)
       hk(j,16) = 2.0D0*(hk(j,8))**(.50D0)/hk(j,4)
       hk(j,17) = (1.0D0 - hk(j,11)/hk(j,3))**(0.50D0)
       hk(j,18) = hk(j,9)*(exp(hk(j,12)/(hk(j,9)*hk(j,3)))
     5  -1.0D0)/hk(j,5)
       hk(j,19) = hk(j,18)+((hk(j,11)/hk(j,3))**hk(j,14)-hk(j,15))/
     6  (hk(j,4)*hk(j,14))
       hk(j,13) = hk(j,19) + hk(j,16)*hk(j,17)
       hk(j,13) = hk(j,13)*hk(j,13)  
c      pt = 0.0D0
c      write(6,*) ' thetas = ', hk(j,3)
c      write(6,*) ' psi 0  = ', hk(j,4)
c      write(6,*) ' psi D  = ', hk(j,5)
c      write(6,*) ' lambda = ', hk(j,6)
c      write(6,*) ' psi i  = ', hk(j,7)
c      write(6,*) ' c      = ', hk(j,8)
c      write(6,*) ' alpha  = ', hk(j,9)
c      write(6,*) ' psi j  = ', hk(j,10)
c      write(6,*) ' thetai = ', hk(j,11)
c      write(6,*) ' thetaj = ', hk(j,12)
c      write(6,*) ' Is**2  = ', hk(j,13)
c      write(6,*) '(l+1)/l = ', hk(j,14)
c      write(6,*) ' 15     = ', hk(j,15)
c      write(6,*) ' 16     = ', hk(j,16)
c      write(6,*) ' 17     = ', hk(j,17)
c      write(6,927)
c  927 format('           hp       theta       slope         Kr')    
c      do 929 k4 = 1, 100
c      pt1 = vsthuot(pt,j)
c      pt2 = vsdthuot(pt,j)
c      pt3 = vshkuot(pt1,j)
c      write(6,928) pt, pt1, pt2, pt3
c      pt = pt - .25
c 929  continue
c 928  format(4D14.4)
      end if
      end if
c
c  end revisions
c
 30    CONTINUE

c     convert alpha parameter if reading version 2.5 data set
      IF (VER2P5.AND.(hydraulicFunctionType.EQ.1)) THEN
         DO 31 J=1,NTEX
            IF (HK(J,4).NE.0) THEN
               HK(J,4) = -1.D0/HK(J,4)  
            END IF
   31    CONTINUE
      ENDIF
      WRITE (06,4140)
C
C    READ TEXTURAL CLASS INDEX MAP
C
      READ (05,*) IROW
      IF(IROW.EQ.0) THEN
      WRITE(06,4090)
      DO 50 J=1,NLY
      READ (05,*) (IDUM(N),N=1,NXR)
      if (ntex.gt.9) then
       write (06,4151) j,(idum(n),n=1,nxr)
      else
       WRITE (06,4150) J,(IDUM(N),N=1,NXR)
      end if
      DO 40 N=1,NXR
      IN=NLY*(N-1)+J
      J22=IDUM(N)
      HX(IN)=HK(J22,1)
   40 JTEX(IN)=J22
   50 CONTINUE
      ELSE
C
C    READ TEXTURE CLASSES BY BLOCK--EITHER CONTINUOUS LAYERS OR
C    LAYERS BOUNDED BY VERTICAL DISCONTINUITIES.
C
      WRITE (06,4040)
      JTP=1
   60 READ (05,*) IL,IR,JBT,JRD
      DO 70 N=IL,IR
      IDUM(N)=JRD
   70 CONTINUE
      IF(IR.LT.NXR) GO TO 60
      DO 80 J=JTP,JBT
      if (ntex.gt.9) then
       write (06,4151) j,(idum(n),n=1,nxr)
      else
       WRITE (06,4150) J,(IDUM(N),N=1,NXR)
      end if
   80 continue
      DO 90 J=JTP,JBT
      DO 90 N=1,NXR
      IN=NLY*(N-1)+J
      J22=IDUM(N)
      HX(IN)=HK(J22,1)
      JTEX(IN)=J22
   90 CONTINUE
      IF(JBT.EQ.NLY) GO TO 100
      JTP=JBT+1
      GO TO 60
      END IF
  100 CONTINUE
C
C   BORDERS OF DOMAIN ARE ALL SET TO NO FLOW BOUNDARIES
C
      DO 110 I=1,NLY
      I1=NNODES-I+1
      HX(I)=0.0D0
  110 HX(I1)=0.0D0
      DO 120 I=2,NXR
      I1=(I-1)*NLY
      HX(I1)=0.0D0
  120 HX(I1+1)=0.0D0
C
C   READ INITIAL HEADS OR MOISTURE CONTENTS
C
      READ (05,*) IREAD,FACTOR
      IF(IREAD.EQ.2) THEN
      READ (05,*) DWTX,HMIN
      WRITE (06,4190) DWTX,ZUNIT,HMIN,ZUNIT,DWTX,ZUNIT
C
C   CALCULATE EQUILIBRIUM INITIAL HEAD PROFILE
C
      DO 130 J=2,NLYY
      DO 130 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).EQ.0.0D0) GO TO 130
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      P1=Z1-DWTX
      IF(P1.LT.HMIN)P1=HMIN
      P(IN)=P1-Z1
      PXXX(IN)=P(IN)
  130 CONTINUE
      ELSE
      IF(IREAD.EQ.0) THEN
      WRITE (6,4170) FACTOR
      ELSE
      if (iread.eq.1) READ (05,*) IU,IFMT
      END IF
c      if(IFMT.eq.UNFORMATTED) then
      if(iread.eq.3) then
       stimStart = -1.d0
       write (6,4181) stim, TUNIT
       if (trans) then
       do 
        read (13,err = 131, end = 132) stimStart, p, cc
        if (stimStart.ge.stim) EXIT
       end do
       else
        do
         read (13,err = 131, end = 132) stimStart, p
         if (stimStart.ge.stim) EXIT
        end do
       end if
 132   continue
       if (stimStart.ne.stim) then
        write (6,4183) stim, TUNIT, stimStart, TUNIT
        stim = stimStart
       end if
       go to 133
 131   write (6,4182)
       jstop = 11
       return
      else
      WRITE (06,4180) IU,FACTOR
      DO 160 J=1,NLY
      IF(IREAD.EQ.1) then
      IF(IFMT.eq.FREE) THEN
C
C   READ INITIAL CONDITIONS FROM FILE IU
C
c      read (iuHead,*) (dum(n),n=1,nxr)
      read (iu,*) (dum(n),n=1,nxr)
      ELSE
c      READ (iuHead,FMT=IFMT) (DUM(N),N=1,NXR)
      READ (iu,FMT=IFMT) (DUM(N),N=1,NXR)
      end if
      else
      DO 140 N=1,NXR
  140 DUM(N)=FACTOR
      end if
      DO 150 N=1,NXR
      IN=NLY*(N-1)+J
      IF(IREAD.ne.0)DUM(N)=DUM(N)*FACTOR
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      IF(.NOT.PHRD) THEN
      IF(DUM(N).LE.0.0D0) THEN
      WRITE(6,4230) J,N
      jstop=4
      return
      END IF
C
C   CONVERT INITIAL MOISTURE CONTENTS TO HEADS
C
      if(hydraulicFunctionType.eq.1) then
       P(IN)=VSTHNVVG(DUM(N),JTEX(IN))-Z1
      else
       if(hydraulicFunctionType.eq.2) then
        P(IN)=VSTHNVHK(DUM(N),JTEX(IN))-Z1
       else
        if(hydraulicFunctionType.eq.0) then
         P(IN)=VSTHNVBC(DUM(N),JTEX(IN))-Z1
        else
         if(hydraulicFunctionType.eq.3) then
          P(IN)=VSTHNVTAB(DUM(N),JTEX(IN))-Z1
         else
          P(IN)=VSTHNVOT(DUM(N),JTEX(IN))-Z1
         end if
        end if
       end if
      end if
      THETA(IN)=DUM(N)
      ELSE
      P(IN)=DUM(N)-Z1
      END IF
      PXXX(IN)=P(IN)
  150 CONTINUE
  160 CONTINUE
      end if
      if(jstop.gt.1) return
C
C   COMPUTE INITIAL NONLINEAR COEFFICIENT VALUES
C
      END IF
 133  CALL VSCOEF
C
C   IF ET IS TO BE SIMULATED, ALL VARIABLES MUST BE ENTERED HERE.
C
      READ(05,*) BCIT,ETSIM
      IF(BCIT .OR. ETSIM) THEN
C
C    COMPUTE DEPTHS FOR ET CALCULATIONS
C
      DPTH(1)=-0.5D0 *DELZ(1)
      DO 170 J=2,NLYY
      DO 170 N=2,NXRR
      IN=NLY*(N-1)+J
      JM1=IN-1
      IF(HX(IN).NE.0.0D0) THEN
      IF(HX(JM1).EQ.0.0D0) THEN
      DPTH(IN)=0.0D0
      ELSE
      DPTH(IN)=DPTH(JM1)+DELZ(J-1)
      END IF
      END IF
  170 CONTINUE
      WRITE (6,4200)
      CALL VSOUT(2,DPTH)
C
C   READ EVAPORATION VARIABLES
C
      READ(05,*)NPV,ETCYC
      npv1 = npv
      if(npv.lt.0) npv = -npv
      include 'd_ptetAlloc.inc'
      DO 713 I=1,NPV
      PEVAL(I) = 0.0D0
      PTVAL(I) = 0.0D0
      DO 714 J=1,6
      RDC(J,I) = 0.0D0
 714  CONTINUE
 713  CONTINUE
      WRITE(6,4030) NPV,ETCYC,TUNIT
      IF(BCIT) THEN
      READ (05,*)(PEVAL(I),I=1,NPV)
      READ(05,*)  (RDC(1,I),I=1,NPV)
      READ(05,*)  (RDC(2,I),I=1,NPV)
      WRITE (06,4050)ZUNIT,TUNIT,ZUNIT,ZUNIT,(I,PEVAL(I),RDC(1,I),RDC(2,
     *I),I=1,NPV)
      END IF
      IF (ETSIM )THEN
C
C   READ TRANSPIRATION VARIABLES
C
      READ(05,*)(PTVAL(I),I=1,NPV)
      READ(05,*) (RDC(3,I),I=1,NPV)
      READ(05,*) (RDC(4,I),I=1,NPV)
      READ(05,*) (RDC(5,I),I=1,NPV)
      READ(05,*) (RDC(6,I),I=1,NPV)
      WRITE(06,4060)ZUNIT,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT,(I,PTVAL(I),
     *(RDC(J,I),J=3,6),I=1,NPV)
      NPV = npv1
      END IF
      END IF
      DO 180 IN=1,NNODES
      NTYP(IN)=0
      NCTYP(IN)=0
      IF(HX(IN).GT.0.0D0) THLST(IN)=THETA(IN)
  180 CONTINUE
C
C    READ INITIAL CONCENTRATIONS IF TRANSPORT EQUATION IS TO
C    BE SOLVED
C
      IF (TRANS.and.iread.ne.3) THEN
      READ(05,*) IREAD,FACTOR
      IF(IREAD.EQ.0) THEN
      WRITE(6,4210) FACTOR
      DO 190 N=1,NNODES
      IF(HX(N).GT.0.0D0) THEN
       CC(N)=FACTOR
       COLD(N)=FACTOR
      ELSE
       CC(N)=0.0D0
       COLD(N)=0.0D0
      END IF
  190 CONTINUE
      ELSE
      READ(05,*)IU,IFMT
      if (IFMT.NE.UNFORMATTED) then
      WRITE(06,4220) IU,FACTOR
      DO 200 J=1,NLY
      if (IFMT.EQ.FREE) then
c       read(iuConcentration,*) (dum(n),n=1,nxr)
       read(iu,*) (dum(n),n=1,nxr)
      else
c       READ(iuConcentration,FMT=IFMT) (DUM(N),N=1,NXR)
       READ(iu,FMT=IFMT) (DUM(N),N=1,NXR)
      end if
      DO 200 N=1,NXR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
       CC(IN)=DUM(N)*FACTOR
       COLD(IN)=CC(IN)
      ELSE
       CC(IN)=0.0D0
       COLD(IN)=0.0D0
      END IF
  200 CONTINUE
      end if
      END IF
C
C   COMPUTE INTERCELL CONDUCTANCES
C
      END IF
      CALL VSHCMP
c
c  modifications Aug 2008 to allow output of
c   fluxes along boundary segment.  Read in
c   cells on selected boundary faces here.
c
      if (f7p) then
       read(5,*) numBF, maxnumcells
       include 'd_BFAlloc.inc'
       do 250 i = 1,numBF
        read(5,*) idBF(i), numcellsBF(i)
        do 250 j = 1,numcellsBF(i)
         read (5,*) jj,nn
         nodenum(i,j) = nly*(nn-1) + jj
 250   continue
      end if  
      RETURN
 4000 FORMAT(10X,27HINITIAL MOISTURE PARAMETERS/10X,27(1H_)//
     &5X,'CONVERGENCE CRITERION FOR SIP FOR FLOW (EPS) =',1PE12.3,1X,A4/
     &5X,'CONVERGENCE CRITERION FOR SIP FOR TRANSPORT (EPS1) =',1PE12.3,1X,
     &/5X,23HDAMPING FACTOR, HMAX = ,1PE12.3)
 4010 FORMAT(5X,46HGEOMETRIC MEAN USED FOR INTERCELL CONDUCTIVITY)
 4020 FORMAT(5X,45HUPSTREAM WEIGHTING USED FOR INTERCELL CONDUCT
     &,5HIVITY)
 4030 FORMAT(//15X,'NUMBER OF EVAPORATION AND/OR EVAPOTRASPIRATION PER'
     &,'IODS = ',I6,/,15X,'LENGTH OF EACH PERIOD = ',F10.4,2X,A4)
 4040 FORMAT(5X,'TEXTURAL CLASSES READ IN BY BLOCK')
 4050 FORMAT(//5X,'EVAPORATION   POTENTIAL      SURFACE   ATMOSHERIC',
     &/'       PERIOD        RATE       RESISTANCE    PRESSURE',
     &/19X,A4,'/',A4,3X,A4,'**(-1)',5X,A4,/,1X,90('-'),
     &25(/,5X,I6,4X,3E14.5))
 4060 FORMAT(//,3X,'TRANSPIRATION   POTENTIAL         ROOT       ACTIVIT
     &Y      ACTIVITY        ROOT',
     &/'       PERIOD        RATE            DEPTH     AT BOTTOM       A
     &T TOP       PRESSURE',/,19X,A4,'/',A4,9X,A4,5X,A4,'**(-2)',4X,A4,
     &'**(-2)',8X,A4,/,1X,90('-'),25(/,5X,I6,4X,5E14.5))
 4070 FORMAT(5X,47HARITHEMTIC MEAN USED FOR INTERCELL CONDUCTIVITY)
 4080 FORMAT(5X,34HNUMBER OF SOIL TEXTURAL CLASSES = ,I10/
     &5X,43HNUMBER OF SOIL PARAMETERS FOR EACH CLASS = ,I10/
     &5X,'NUMBER OF TRANSPORT PARAMETERS FOR EACH CLASS = ',I10/
     &5X,47HMINIMUM PERMITTED NO. OF ITERATIONS/TIME STEP =,I10/
     &5X,47HMAXIMUM PERMITTED NO. OF ITERATIONS/TIME STEP =,I10)
 4090 FORMAT(5X,41HTEXTURAL CLASS TO BE READ IN FOR EACH ROW)
 4100 FORMAT(41X,35HCONSTANTS FOR SOIL TEXTURAL CLASSES//
     &10X,10HANISOTROPY,7X,4HKSAT,5X,8HSPECIFIC,4X,8HPOROSITY,/,
     &36X,7HSTORAGE)
 4110 FORMAT(12X,'ALPHAL',8X,'ALPHAT',6X,'DM',9X,'LAMBDA',
     &4X,'B DENSITY')
 4120 FORMAT(1X,7HCLASS #,I2,/9X,3(1PD12.3),14(7(1PD12.3),/))
 4130 FORMAT(9X,10(1PD12.3))
 4140 FORMAT(6X,24HTEXTURAL CLASS INDEX MAP//   )
 4150 FORMAT(1H ,5X,I5,2X,100(99999I1))
 4151 FORMAT(1H ,5X,I5,2X,100(99999I2))
 4160 FORMAT(5X,24H ****** VALUE OF ITMAX =,I5,8HEXCEEDS ,
     &44HDIMENSION OF DHMX, PROGRAM TERMINATED ******)
 4170 FORMAT(5X,48HINITIAL PRESSURE HEAD OR MOISTURE CONTENT WAS SE,
     & 24HT TO A CONSTANT VALUE OF,1PE12.3)
 4180 FORMAT(5X,48HINITIAL PRESSURE HEAD OR MOISTURE CONTENT WAS RE,
     & 12HAD FROM UNIT,I5,
     & 20H A SCALING FACTOR OF,1PE12.3,9H WAS USED)
 4181 FORMAT(5X,'Simulation restarted at time ', E15.7,1x, a4,  
     & '.  Initial conditions imported from previous run.')
 4182 FORMAT('Error reading unformatted initial conditions.',
     & '  Simulation stopped.')
 4183 FORMAT(5x,'WARNING ---- Requested start time ', E15.7,1x, a4, 
     & ' differs from actual start time ', E15.7,1x, a4,'.')
 4190 FORMAT(5X,'EQUILLIBRIUM PROFILE USED TO INITIALIZE PRESSURE',
     & 27H HEADS ABOVE WATER TABLE AT,F10.2,1X,A4,1X,
     & 12HBELOW ORIGIN/5X,
     & 57HEQUILLIBRIUM PROFILE ONLY USED UNTIL PRESSURE HEADS EQUAL,
     &  F10.2,1X,A4/5X,
     & 20HPRESSURE HEADS BELOW,F10.2,1X,A4,16H ARE HYDROSTATIC)
 4200 FORMAT(1H ,50X,18HDEPTH FROM SURFACE)
 4210 FORMAT('     INITIAL CONCENTRATION SET TO A CONSTANT VALUE OF ',
     &1PE12.3)
 4220 FORMAT('     INITIAL CONCENTRATION WAS READ FROM UNIT',I5,
     &' A SCALING FACTOR OF, ',1PE12.3,' WAS USED')
 4230 FORMAT('  INITIAL MOISTURE CONTENT AT ROW ',I3,' COLUMN ',
     &I3,' IS LESS THAN OR EQUAL TO 0.',/'  PROGRAM TERMINATED')
      END
      SUBROUTINE VSTMER
C******
CVSTMER
C******
C
C     PURPOSE: TO CONTROL THE TIME SEQUENCE OF SIMULATION
C     AND TO READ NEW BOUNDARY CONDITION DATA
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_trxx.inc'
      include 'd_plott.inc'
      include 'd_idumm.inc'
      include 'd_spfc.inc'
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_trxx.inc'
c      include 'c_plott.inc'
c      include 'c_idumm.inc'
c      include 'c_spfc.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/PND/POND
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      CHARACTER*80 TITL
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      COMMON/VERSION/VER2P5
      LOGICAL VER2P5
      SAVE STERR
C-------------------------------------------------------------------
C
C   ADVANCE TO NEXT TIME STEP
C
      KTIM=KTIM+1
      IF (KTIM.NE.1.AND.JSTOP.NE.0) RETURN
      JSTOP=0
      JPLT=0
      NIT=0
      NIT1=0
      IF(KTIM.EQ.1) then
       kplt = 1
       do
        if(pltim(kplt).gt.stim) EXIT
        kplt = kplt + 1
       end do
      end if
      IF(JFLAG.EQ.1) THEN
C
C ................................................................
C
C    READ DATA FOR NEW RECHARGE PERIOD
C ................................................................
C
      READ (05,*) TPER,DELT
C
C   CHECK FOR END OF SIMULATION
C
      jflag1 = 1
      IF(((.NOT.VER2P5).AND.(TPER.LT.0D0)).OR.
     &   (VER2P5.AND.(TPER.GE.999998.D0))) THEN
      WRITE (06,4070) TMAX,STIM
      jstop=5
      return
      END IF
      READ (05,*) TMLT,DLTMX,DLTMIN,TRED
      KP=KP+1
      SSTATE=.FALSE.
      if(delt.lt.dltmin) then
       delt = dltmin
      else
       if(delt.gt.dltmx) delt = dltmx
      end if
      WRITE (06,4000) KP,TPER,TUNIT,DELT,TUNIT,TMLT,DLTMX,TUNIT,DLTMIN,
     *TUNIT,TRED
      READ (05,*) DSMAX,STERR
      READ (05,*) POND
      WRITE (06,4020) DSMAX,STERR,POND
      READ (05,*) PRNT
      READ (05,*) BCIT,ETSIM,SEEP
      WRITE (06,4010) PRNT,BCIT,ETSIM,SEEP
      DSMAX=DABS(DSMAX)
      ETOUT=0.0D0
      ETOUT1=0.0D0
C
C    READ SEEPAGE FACE DATA
C
      IF(SEEP) THEN
      READ (05,*) NFCS
      include 'd_spfcAlloc.inc'
      DO 20 K=1,NFCS
      READ (05,*) JJ,JLAST(K)
      NFC(K)=JJ
      READ (05,*) ((JSPX(L,J,K),L=2,3),J=1,JJ)
      DO 10 J=1,JJ
      J1=JSPX(2,J,K)
      N1=JSPX(3,J,K)
      N2=NLY*(N1-1)+J1
      JSPX(1,J,K)=N2
      Q(N2)=0.0D0
      QQ(N2)=0.0D0
      NCTYP(N2)=0
      CS(N2)=0.0D0
      IF(J.GT.JLAST(K)) THEN
      NTYP(N2)=3
      ELSE
      NTYP(N2)=1
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J1)
      ELSE
      Z1=DZZ(J1)*CS1+RX(N1)*CS2
      END IF
      P(N2)=-Z1
      END IF
   10 CONTINUE
   20 CONTINUE
      END IF
C
C   READ IN NEW BOUNDARY CONDITIONS FOR RECHARGE PERIOD
C    IF IBC=0, POINT BOUNDARY CONDITIONS ARE READ IN.
C    IF IBC=1, LINE BOUNDARY CONDITIONS ARE READ IN, AND IT IS NECESSARY
C     TO SPECIFY FOUR POINTS ON THE LINE--THIS ALLOWS VERTICAL OR HORI-
C     ZONTAL LINES TO BE READ IN INDISCRIMINATELY.  THE SEQUENCE IS:
C     TOP ROW, BOTTOM ROW, LEFT COLUMN, RIGHT COLUMN, CODE, AND FLUX OR
C     PRESSURE HEAD FOR BOUNDARY CONDITION.
C
      READ (05,*) IBC
      IF(IBC.GT.0) GO TO 40
   30 IF (TRANS) THEN
      READ(05,*) JJ,NN,NTX,PFDUM,NTC,CF
      ELSE
      READ (05,*) JJ,NN,NTX,PFDUM
      CF=0.0D0
      NTC=0
      END IF
      IF(((.NOT.VER2P5).AND.(JJ.LT.0)).OR.
     &   (VER2P5.AND.(JJ.GE.999998))) GO TO 90
      JJT=JJ
      JJB=JJ
      NNL=NN
      NNR=NN
      GO TO 50
   40 IF (TRANS) THEN
      READ(05,*) JJT,JJB,NNL,NNR,NTX,PFDUM,NTC,CF
      ELSE
      READ (05,*) JJT,JJB,NNL,NNR,NTX,PFDUM
      CF=0.0D0
      NTC=0
      END IF
      IF(((.NOT.VER2P5).AND.(JJT.LT.0)).OR.
     &   (VER2P5.AND.(JJT.GE.999998))) GO TO 90
   50 CONTINUE
      DO 80 JJ=JJT,JJB
      DO 80 NN=NNL,NNR
      IN=NLY*(NN-1)+JJ
      CS(IN)=CF
c
c  change made 99-12-16 so that ntc = 2 diffusive mass flux is
c   in terms of mass per time per length of boundary (i.e.,
c   a line source) , as 
c   opposed to mass per time (which is for point source)
c
      if (ntc.eq.2) then
       area = dxr(nn)
       if(rad) area = pi2*rx(nn)*dxr(nn)
       cs(in) = cf*area
      end if
c
      IF(NTC.EQ.1) CC(IN)=CF
      NCTYP(IN)=NTC
c      if(ntx.eq.5.and.hx(in-1).gt.0.0d0) go to 80
      IF(NTX.NE.6) GO TO 60
      NTYP(IN)=2
      QQ(IN)=PFDUM
      GO TO 80
   60 NTYP(IN)=NTX
      IF(NTX .EQ. 4)NTYP(IN)=1
      IF(NTX.EQ.0) WRITE (06,4030) JJ,NN
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(JJ)
      ELSE
      Z1=DZZ(JJ)*CS1+RX(NN)*CS2
      END IF
      IF(NTX.EQ.1) P(IN)=PFDUM-Z1
      IF(NTX.EQ.4) P(IN)=PFDUM
      IF(NTX.EQ.2) GO TO 70
      QQ(IN)=0.0D0
c
c  modifications for gravity drainage BC
c
      if (ntx.eq.7) then
       if(hx(in+1).gt.0.d0.or.hx(in-1).le.0.d0) then
        WRITE(6,4012)  JJ,NN
        ntyp(in)=0
       else
c        nctyp(in) = 7
        ntyp(in) = 7
       end if
      end if
c
c  end modifications
c 
      GO TO 80
   70 CONTINUE
C
C    SET QQ TO RAINFALL RATE
C
      AREA=DXR(NN)
      IF(RAD)AREA=PI2*RX(NN)*DXR(NN)
      QQ(IN)=PFDUM*AREA
   80 CONTINUE
      IF(IBC.EQ.0) GO TO 30
      GO TO 40
   90 CONTINUE
C
C     WRITE INITIAL BOUNDARY CONDITIONS FOR THIS PERIOD
C
      GRAV = .FALSE.
      WRITE (06,4040) KP
      DO 110 J=1,NLY
      DO 100 N=1,NXR
      IN=NLY*(N-1)+J
      Q(IN)=0.0D0
      if(ntyp(in).eq.7) GRAV = .TRUE.
  100 IDUM(N)=NTYP(IN)
  110 WRITE (06,4050) J,(IDUM(I),I=1,NXR)
      TMPX=STIM+TPER
      IF(TMPX+0.5D0*DLTMIN.GT.TMAX) TMPX=TMAX
C
C   CALCULATE NEW COEFFICIENTS
C
      IF(KTIM.NE.1)CALL VSCOEF
      END IF
C
C   INITIALIZE REQUIRED ARRAYS FOR NEW BOUNDARY CONDITION, UPDATE
C   PXXX,THLST.  COMPUTE MAXIMUM HEAD CHANGE DURING LAST TIME STEP
C
      PDIF=0.0D0
      IF(.NOT.SSTATE) THEN
      DO 120 J=2,NLYY
      DO 120 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).EQ.0.0D0) GO TO 120
      P12=P(IN)-PXXX(IN)
      PTMP=DABS(P12)
      IF(PTMP.GT.PDIF)PDIF=PTMP
      PXXX(IN)=P(IN)
      THLST(IN)=THETA(IN)
  120 CONTINUE
C
C    CHECK FOR STEADY STATE
C
      IF(jflag.ne.1.and.PDIF.LE.STERR) THEN
      SSTATE=.TRUE.
      WRITE(6,4060) STIM,KTIM
      END IF
      END IF
      JFLAG=0
C
C   INITIALIZE DHMX
C
      DO 130 K=1,itmax
  130 DHMX(K)=0.0D0
C
C    ADVANCE DELT AND RESET TO PROPER LENGTH IF NECESSARY
C
      if (delt.lt.dltmin) delt = dltmin
      DLTOLD=DELT
      DELT= TMLT*DELT
C
C    MAXIMUM PERMISSABLE HEAD CHANGE CHECK
C
      IF(KTIM.GE.2) THEN
      IF((PDIF*DELT/DLTOLD).GT.DSMAX)DELT=DLTOLD*DSMAX*0.98D0/PDIF
      END IF
c      IF(DABS(TMPX-PLTIM(KPLT)).LT.DLTMIN) PLTIM(KPLT)=TMPX
      T1=DMIN1(TMPX,PLTIM(KPLT))
      T2=T1-STIM
c
c  changes made 6-12-02 for calculating delt.  This new
c  version will allow delt<dltmin only to match obs times
c  or end of recharge period.
c  THESE NEED TO BE CHECKED CAREFULLY
c
c      IF(DELT.GT.(T2-DLTMIN)) DELT=T2
c      IF(DELT.LT.DLTMIN)DELT=DLTMIN
      if(delt.gt.t2) then
       delt = t2
      else
       if(delt.lt.dltmin) delt = dltmin
      end if
c      IF(DELT.GT.DLTMX)DELT=DLTMX
       if(delt-dltmx.ge.0.000001D0*dltmin) delt = dltmx
c      IF(T1.NE.PLTIM(KPLT).OR.T2-DELT.GT.0.5D0*DLTMIN) GO TO 140
      IF(T1.NE.PLTIM(KPLT).or.t2-delt.gt.0.d0) GO TO 140
      KPLT=KPLT+1
      JPLT=1
c  140 IF(DELT.LT.DLTMIN)DELT=DLTMIN
 140  continue
      STIM=STIM+DELT
c      IF (TMPX-STIM.LT.0.5D0*DLTMIN) JFLAG=1
c      IF(TMAX-STIM.LT.0.5D0*DLTMIN) THEN
c      IF (TMPX-STIM.LT.0.000001D0*DLTMIN) JFLAG=1
      IF (TMPX-STIM.LT.0.000001D0*DLTMIN) then
       JFLAG=1
       JPLT=1
       delt = delt + (tmpx - stim)
       stim = tmpx
       do
        if (stim.lt.pltim(kplt)) exit
        kplt = kplt + 1
       end do
      end if
      IF(TMAX-STIM.LT.0.000001*DLTMIN) THEN
c
c  end changes of 6-12-02
c
      JSTOP=1
      JPLT=1
      ELSE
      IF(KTIM.GT.NUMT) THEN
      JSTOP=8
      JPLT=1
      WRITE(6,4080)
      END IF
      END IF
      RETURN
 4000 FORMAT(6X,'DATA FOR RECHARGE PERIOD ',I9//10X,
     &23HLENGTH OF THIS PERIOD =,1PE14.5,1X,A4,/10X,
     &45HLENGTH OF INITIAL TIME STEP FOR THIS PERIOD =,1PE14.5,1X,A4/
     &10X,27HMULTIPLIER FOR TIME STEP = ,1PE10.3,/10X,
     &25HMAXIMUM TIME STEP SIZE = ,1PE14.5,1X,A4/10X,
     &25HMINIMUM TIME STEP SIZE = ,1PE14.5,1X,A4,
     &/10X,'TIME STEP REDUCTION FACTOR = ',1PE10.3)
 4010 FORMAT(15X,37HPRINT SOLUTION AFTER EVERY TIME STEP?,1X,L1/
     &15X,'SIMULATE EVAPORATION? ',L1/
     &15X,29HSIMULATE EVAPOTRANSPIRATION? ,L1/
     &15X,24HSIMULATE SEEPAGE FACES? ,L1/)
 4012 format(16x,'WARNING -- GRAVITY BOUNDARY NODE MUST LIE ABOVE ',
     &'AN INACTIVE NODE.'/16X,'AND BELOW AN ACTIVE NODE.'/16X,
     &'GRAVITY BOUNDARY NOT APPLIED FOR CELL: '
     &,2I6/)
 4020 FORMAT(
     &15X,55HMAXIMUM PRESSURE HEAD CHANGE ALLOWED IN ONE TIME STEP =,
     &F8.3/15X,'STEADY-STATE CLOSURE CRITERION = ',1PE10.3/
     &15X,'MAXIMUM DEPTH OF PONDING = ',1PE10.3)
 4030 FORMAT(1X,'******** WARNING --- NODE TYPE OF 0 ASSIGNED TO BO',
     &'UNDARY NODE ',2I5)
c
 4040 FORMAT(6X,41HNODE TYPE AND INITIAL BOUNDARY CONDITIONS,
     &12H FOR PERIOD ,I9/6X,8HLEGEND: /15X,17H0 = INTERIOR CELL/
     &15X,32H1 = SPECIFIED PRESSURE HEAD CELL/15X,
     &23H2 = SPECIFIED FLUX CELL/
     & 15X,31H3 = POTENTIAL SEEPAGE FACE NODE/
     & 15X,43H5 = NODE FOR WHICH EVAPORATION IS PERMITTED/
     & 15x,'7 = GRAVITY DRAIN CELL'/)
 4050 FORMAT(1H ,I5,5X,100(99999I1))
 4060 FORMAT(6X,100(1H*)/5X,
     &'STEADY STATE REACHED AT TIME = ',E14.6,'   TIME STEP NUMBER = '
     &,I9//)
 4070 FORMAT(6X,100(1H*),/,5X,17HEND OF SIMULATION/,
     &5X,33HMAXIMUM SIMULATION TIME (TMAX) = ,E15.6/,
     &5X,33HELAPSED SIMULATION TIME (STIM) = ,E15.6/,
     &6X,100(1H*))
 4080 FORMAT(' Maximum number of time steps exceeded'/
     1' Simulation terminated')
      END
      SUBROUTINE VSMGEN
C******
CVSMGEN
C******
C
C    PURPOSE:  TO SET UP COEFFICIENT MATRICES AND CALL
C          SOLUTION ALGORITHM
C
C-----------------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_hcon.inc'
      include 'd_equat.inc'
      include 'd_jtxx.inc'
      include 'd_ptet.inc'
      include 'd_pit.inc'
      include 'd_plott.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_hcon.inc'
c      include 'c_equat.inc'
c      include 'c_jtxx.inc'
c      include 'c_ptet.inc'
c      include 'c_pit.inc'
c      include 'c_plott.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/WGT/WUS,WDS
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      CHARACTER*80 TITL
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      integer hydraulicFunctionType, adsorptionType
      common/functiontype/ hydraulicFunctionType, adsorptionType
C
C ......................................................................
C  START OF LINEARIZATION ITERATION LOOP
C. .....................................................................
C
C    UPDATE COEFFICIENTS
C
      I13=0
C
C     ESTABLISH TIME-DEPENDENT PARAMETERS GOVERNING EVAPORATION AND
C     TRANSPIRATION.  DETERMINE ROOT ACTIVITY.
C
   10 IF ( BCIT.OR. ETSIM) THEN
      CALL VSPET
      DO 20 J=2,NLYY
      DO 20 I=2,NXRR
      N=NLY*(I-1)+J
      IF(HX(N).GT.0.0D0) THEN
      IF(ETSIM) RT(N)=VSRDF(DPTH(N),DELZ(J))
      Q(N)=0.0D0
      END IF
   20 CONTINUE
      END IF
   30 IF (NIT.NE.0) CALL VSCOEF
C
C --------------------  UPDATE BOUNDARY AND FLUX CONDITIONS ------------
C
      IF(BCIT)CALL VSEVAP
      IF (ETSIM)CALL VSPLNT
      IF(SEEP) CALL VSSFAC
      if(GRAV.and.nit.eq.0) CALL vsgrav_dr
C
C .....................................................................
C
C         LOOP TO CALCULATE COEFFICIENT MATRIX
C .....................................................................
C
      DO 40 J=2,NLYY
      DO 40 I=2,NXRR
      N=NLY*(I-1)+J
      IF(HX(N).GT.0.0D0) THEN
      JM1=N-1
      JP1=N+1
      IM1=N-NLY
      IP1=N+NLY
      VOL=DXR(I)*DELZ(J)
      IF(RAD)VOL=PI2*RX(I)*DXR(I)*DELZ(J)
      JJ=JTEX(N)
C
C   CALCULATE STORAGE TERMS
C
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      PTMP=P(N)+Z1
      if(hydraulicFunctionType.eq.1) then
       SCAP=VSDTHUVG(PTMP,JJ)
      else
       if(hydraulicFunctionType.eq.2) then
        SCAP=VSDTHUHK(PTMP,JJ)
       else
        if(hydraulicFunctionType.eq.0) then
         SCAP=VSDTHUBC(PTMP,JJ)
        else
         if(hydraulicFunctionType.eq.3) then
          SCAP=VSDTHUTAB(PTMP,JJ)
         else
          SCAP=VSDTHUOT(PTMP,JJ)
         end if
        end if
       end if
      end if
      GSF=VOL*SCAP
      if (HK(JJ,3).ne. 0.0D0) then
       SS=HK(JJ,2)/HK(JJ,3)
      else
       SS=0.0D0
      end if
      GSS=VOL*THETA(N)*SS
      G1=0.0D0
C
C   APPLY NEWTON-RAPHSON LINEARIZATION TO STORAGE TERM.
C   PITT HOLDS STORAGE TERMS FROM PREVIOUS ITERATION.
C
      IF(NIT.GT.0.AND.XI(N).NE.0.0D0) G1=(P(N)-PXXX(N))*
     &                                   (GSF+GSS-PITT(N))/XI(N)
      PITT(N)=GSF+GSS
      G1=-G1/DELT
      GSF=-GSF/DELT
      GSS=-GSS/DELT
      IF(WUS.EQ.0.0D0) THEN
C
C   USE GEOMETRIC MEAN OR WEIGHTS FOR INTERCELL K
C
      A(N)=HKLL(N)*DSQRT(HCND(IM1)*HCND(N))
      B(N)=HKTT(N)*DSQRT(HCND(JM1)*HCND(N))
      C(N)=HKLL(IP1)*DSQRT(HCND(IP1)*HCND(N))
      D(N)=HKTT(JP1)*DSQRT(HCND(JP1)*HCND(N))
      ELSE
C
C  CHOOSE UPSTREAM WEIGHTING COEFFICIENTS
C
      IF(P(IM1).LE.P(N).OR.HX(IM1).EQ.0.0D0) THEN
      ALA=WDS
      BTA=WUS
      ELSE
      ALA=WUS
      BTA=WDS
      END IF
      IF(P(JM1).LE.P(N).OR.HX(JM1).EQ.0.0D0) THEN
      ALB=WDS
      BTB=WUS
      ELSE
      ALB=WUS
      BTB=WDS
      END IF
      IF(P(IP1).LE.P(N).OR.HX(IP1).EQ.0.0D0) THEN
      ALC=WDS
      BTC=WUS
      ELSE
      ALC=WUS
      BTC=WDS
      END IF
      IF(P(JP1).LE.P(N).OR.HX(JP1).EQ.0.0D0) THEN
      ALD=WDS
      BTD=WUS
      ELSE
      ALD=WUS
      BTD=WDS
      END IF
C
C   SET THE PENTA-DIAGNOL COEFFICIENT MATRIX (E IS MAIN DIAGNOL)
C   AND RIGHT HAND SIDE
C
      A(N)=(ALA*HCND(IM1)+BTA*HCND(N))*HKLL(N)
      B(N)=(ALB*HCND(JM1)+BTB*HCND(N))*HKTT(N)
      C(N)=(ALC*HCND(IP1)+BTC*HCND(N))*HKLL(IP1)
      D(N)=(ALD*HCND(JP1)+BTD*HCND(N))*HKTT(JP1)
      END IF
      if(ntyp(n).eq.1) then
       if(ntyp(im1).eq.1) a(n) = 0.0d0
       if(ntyp(jm1).eq.1) b(n) = 0.0d0
       if(ntyp(ip1).eq.1) c(n) = 0.0d0
       if(ntyp(jp1).eq.1) d(n) = 0.0d0
      end if
      E(N)=-A(N)-B(N)-C(N)-D(N)
      RHS(N)=VOL*(THETA(N)-THLST(N))/DELT-(Q(N)+QQ(N))-(A(N)*P(IM1)+B(N)
     &*P(JM1)+C(N)*P(IP1)+D(N)*P(JP1)+(E(N)+GSS)*P(N))+GSS*PXXX(N)
      E(N)=E(N)+GSF+GSS+G1
      END IF
   40 CONTINUE
C
C    CALL SOLUTION ALGORITHM
C
      NIT=NIT+1
      CALL SLVSIP
      IF(NIT.LT.MINIT) GO TO 30
C
C   IF SOLUTION HAS BEEN FOUND THEN RETURN
C
      IF(ITEST.EQ.0) RETURN
      IF(NIT.LE.ITMAX) GO TO 30
C
C   MAXIMUM NUMBER OF ITERATIONS EXCEEDED
C
      WRITE (6,4000) NIT,KTIM,STIM,TUNIT
C
C   AUTOMATICALLY REDUCE TIME STEP SIZE, BUT NOT MORE
C   THAN TWICE.
C
      IF(DELT.LE.DLTMIN.OR.I13.GT.2.OR.TRED.LE.0.0D0) THEN
      IF(.NOT.ITSTOP)RETURN
C
C   TERMINATE SIMULATION.
C
      JSTOP=9
      JFLAG=1
      WRITE(6,4020)
      RETURN
      ELSE
      I13=I13+1
      DELTT=DELT*TRED
      IF(DELTT.LT.DLTMIN) DELTT=DLTMIN
      if(delt-deltt.ge.dltmin) then
       jflag = 0
       if(jstop.eq.1) then
        jstop = 0
        jplt = 0
       else
        if(jplt.eq.1) then
         jplt = 0
         if(stim.eq.pltim(kplt-1)) kplt = kplt - 1
        end if
       end if
      end if
      WRITE(6,4010) DELTT
      STIM=STIM-DELT+DELTT
      DELT=DELTT
C
C   RESET HEADS TO VALUES AT END OF PREVIOUS TIME STEP.
C
      DO 50 II=1,NNODES
      IF(NTYP(II).NE.1.AND.HX(II).GT.0.0D0) P(II)=PXXX(II)
   50 CONTINUE
      NIT=1
      GO TO 10
      END IF
 4000 FORMAT(5X,100(1H*)/5X,'EXCEEDED PERMITTED NUMBER OF ITERATIONS',
     &'  ( =',I9,')'
     & /5X,'TIME STEP NUMBER',I9/5X,'ELAPSED TIME = ',
     & 1PE14.5,1X,A4  /5X,100(1H*))
 4010 FORMAT(5X,'TIME STEP SIZE REDUCED TO ',E14.6)
 4020 FORMAT('Simulation terminated')
      END
      SUBROUTINE VSSIP
C
C*****
CVSSIP
C*****
C
C     PURPOSE: TO SOLVE THE  MATRIX EQUATIONS USING THE
C     STRONGLY IMPLICIT METHOD
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_press.inc'
      include 'd_equat.inc'
      include 'd_jtxx.inc'
      include 'd_trxx.inc'
      include 'd_sip.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_press.inc'
c      include 'c_equat.inc'
c      include 'c_jtxx.inc'
c      include 'c_trxx.inc'
c      include 'c_sip.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      DIMENSION IORDER(21)
      DIMENSION TEMP(100),HM(30)
      SAVE HM,W1,W9,L2,NTH
      DATA W1/0.0D0/
C
C-------------------------------------------------------------------
C
      DATA IORDER/1,2,3,4,5,1,2,3,4,5,11*1/
C
C     COMPUTE ITERATION PARAMETERS
C
      J2=NXR-2
      I2=NLY-2
      L2=5
      PL2=L2-1
      W=0.0D0
      PIE=0.0D0
      W9=100.0D0
C
C  COMPUTE MAXIMUM PARAMETER
C
      DO 10 I=2,NLYY
      DO 10 J=2,NXRR
      N=NLY*(J-1)+I
      IF(HX(N).GT.0.0D0) THEN
      IM1=JTEX(N)
      PIE=PIE+1.0D0
      DX=DXR(J)/RX(NXR)
      DY=DELZ(I)/DZZ(NLY)
      DX3=DX*DX
      DY2=DY*DY
      W=W+1.0D0-DMIN1((DX3+DX3)/(1.0D0+ANIZ(IM1)*DX3/DY2),(DY2+DY2)/
     &(1.0D0+DY2/(ANIZ(IM1)*DX3)))
      END IF
   10 CONTINUE
      W=W/PIE
C
C COMPUTE PARAMETERS IN GEOMETRIC SEQUENCE
C
      PJ=-1.0D0
      DO 20 I=1,L2
      PJ=PJ+1.0D0
   20 TEMP(I)=1.0D0 -(1.0D0 -W)**(PJ/PL2)
C
C ORDER SEQUENCE OF PARAMETERS
C
      DO 30 J=1,L2
   30 HM(J)=TEMP(IORDER(J))
c      WRITE (06,4000) L2,(HM(J),J=1,L2)
      RETURN
C
C STRONGLY IMPLICIT ALGORITHM
C
      ENTRY SLVSIP
      I2=NLY-2
      J2=NXR-2
C
C      SELECT ITERATION PARAMETER.  INITIALIZE ARRAYS
C
      IF(TRANS1) THEN
C
C  IF TRANS1=T  TRANSPORT EQUATION IS SOLVED
C           =F  FLOW EQUATION IS SOLVED
C
      NT=NIT1
      ELSE
      NT=NIT
      END IF
      IF(MOD(NT,L2).EQ.0.OR.NT.EQ.1)NTH=0
      NTH=NTH+1
      W=HM(NTH)
      ITEST=0
      DO 40 I=1,NNODES
      DEL(I)=0.0D0
      ETA(I)=0.0D0
      V(I)=0.0D0
   40 XI(I)=0.0D0
      BIGI=0.0D0
      BIGI1=0.0D0
C
C CHOOSE SIP NORMAL OR REVERSE ALGORITHM
C
      IF(MOD(NT,2)) 50,80,50
C ......................................................................
C ORDER EQUATIONS WITH ROW 1 FIRST  -  3X3 EXAMPLE:
C    1 2 3
C    4 5 6
C    7 8 9
C ......................................................................
   50 DO 60 I=2,NLYY
      DO 60 J=2,NXRR
      N=I+NLY*(J-1)
C
C   ---- SKIP COMPUTATIONS OF NODE IS OUTSIDE OF SOLUTION DOMAIN
C
      IF(HX(N).EQ.0.0D0) GO TO 60
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NCTYP(N).EQ.1
     *)))GO TO 60
      NL=N-NLY
      NA=N-1
      NB=N+1
C
C     --- SIP "NORMAL" ALGORITHM-----
C     --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V --
C
      CH=DEL(NA)*B(N)/(1.0D0 +W*DEL(NA))
      GH=ETA(NL)*A(N)/(1.0D0 +W*ETA(NL))
      BH=B(N)-W*CH
      DH=A(N)-W*GH
      EH=E(N)+W*CH+W*GH
      FH=C(N)-W*CH
      HH=D(N)-W*GH
      ALFA=BH
      BETA=DH
      GAMA=EH-ALFA*ETA(NA)-BETA*DEL(NL)
      DEL(N)=FH/GAMA
      ETA(N)=HH/GAMA
      RES=RHS(N)
      V(N)=(HMAX*RES-ALFA*V(NA)-BETA*V(NL))/GAMA
   60 CONTINUE
C
C  ---BACK SUBSTITUTE FOR VECTOR XI
C
      DO 70 I=1,I2
      I3=NLY-I
      DO 70 J=1,J2
      J3=NXR-J
      N=I3+NLY*(J3-1)
      IF(HX(N).EQ.0.0D0) GO TO 70
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NCTYP(N).EQ.1
     *)))GO TO 70
      XI(N)=V(N)-DEL(N)*XI(N+NLY)-ETA(N)*XI(N+1)
C
C      FIND MAXIMUM HEAD CHANGE
C
      TCHK=DABS(XI(N))
      IF(TCHK.GE.BIGI) THEN
      BIGI=TCHK
      BIGI1=XI(N)
      END IF
   70 CONTINUE
      GO TO 110
C
C.......................................................................
C  ---ORDER EQUATIONS WITH THE LAST ROW FIRST  -  3X3 EXAMPLE
C           7 8 9
C           4 5 6
C           1 2 3
C.......................................................................
C
   80 DO 90 II=1,I2
      I=NLY-II
      DO 90 J=2,NXRR
      N=I+NLY*(J-1)
      NL=N-NLY
      NA=N-1
      NB=N+1
C
C  -- SKIP COMPUTATIONS IF NODE IS OUTSIDE OF SOLUTION DOMAIN
C
      IF(HX(N).EQ.0.0D0) GO TO 90
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NCTYP(N).EQ.1
     *)))GO TO 90
C
C ------ SIP "REVERSE" ALGORITHM
C --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V
C
      CH=DEL(NB)*D(N)/(1.0D0 +W*DEL(NB))
      GH=ETA(NL)*A(N)/(1.0D0 +W*ETA(NL))
      BH=D(N)-W*CH
      DH=A(N)-W*GH
      EH=E(N)+W*CH+W*GH
      FH=C(N)-W*CH
      HH=B(N)-W*GH
      ALFA=BH
      BETA=DH
      GAMA=EH-ALFA*ETA(NB)-BETA*DEL(NL)
      DEL(N)=FH/GAMA
      ETA(N)=HH/GAMA
      RES=RHS(N)
      V(N)=(HMAX*RES-ALFA*V(NB)-BETA*V(NL))/GAMA
   90 CONTINUE
C
C --- BACK SUBSTITUTE FOR VECTOR XI
C
      DO 100 I3=2,NLYY
      DO 100 J=1,J2
      J3=NXR-J
      N=I3+NLY*(J3-1)
      IF(HX(N).EQ.0.0D0) GO TO 100
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NCTYP(N).EQ.1
     *)))GO TO 100
      XI(N)=V(N)-DEL(N)*XI(N+NLY)-ETA(N)*XI(N-1)
C
C      FIND MAXIMUM HEAD CHANGE
C
      TCHK=DABS(XI(N))
      IF(TCHK.GE.BIGI) THEN
      BIGI=TCHK
      BIGI1=XI(N)
      END IF
  100 CONTINUE
C
C      COMPUTE RELAXATION PARAMETER W FOR HEAD CHANGES.  ALGORITHM
C      IS FROM COOLEY (1983)
C
  110 S=1.0D0
      IF(NT.GT.1.AND.W1.NE.0.0D0) S=BIGI1/W1
      S1=DABS(S)
      IF(S.LT.-1.0D0) THEN
      W=1.0D0/(S1+S1)
      ELSE
      W=(3.0D0+S)/(3.0D0+S1)
      END IF
      IF(W.EQ.W9) W=0.9D0*W
      W1=W*BIGI
      IF(W1.GT.DSMAX) W=DSMAX/BIGI
      IF(BIGI1.LT.0.0D0) W1=-W1
C
C      ADD CHANGES TO MATRIX.
C
      W9=W
      IF(TRANS1) THEN
      DO 120 N=NLY+1,NNODES
      IF(NCTYP(N).NE.1.AND.HX(N).GT.0.0D0) CC(N)=CC(N)+W*XI(N)
  120 CONTINUE
      IF(BIGI.GT.EPS1) ITEST=1
      ELSE
      DO 130 N=NLY+1,NNODES
      IF(HX(N).GT.0.0D0.AND.NTYP(N).NE.1) P(N)=P(N)+W*XI(N)
  130 CONTINUE
C
C      COMPARE MAXIMUM HEAD CHANGE TO CLOSURE CRITERION.
C
      IF(BIGI.GT.EPS) ITEST=1
      DHMX(NIT)=BIGI
      END IF
      RETURN
c 4000 FORMAT(1X,I5,25HSIP ITERATION PARAMETERS:,6D15.7/(28X,6D15.7/))
      END
      SUBROUTINE VSCOEF
C******
CVSCOEF
C******
C     PURPOSE: TO COMPUTE ALL VALUES OF NONLINEAR COEFFICIENTS
C              USING THE MOST RECENT VALUES OF PRESSURE HEAD
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_hcon.inc'
      include 'd_jtxx.inc'
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_hcon.inc'
c      include 'c_jtxx.inc'
c      include 'c_rprop.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      integer hydraulicFunctionType, adsorptionType
      common/functiontype/ hydraulicFunctionType, adsorptionType
C
C-------------------------------------------------------------------
      if(hydraulicFunctionType.eq.1) then
c
c       Van Genuchten functions are used
c
      DO 10 J=2,NLYY
      DO 10 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
C
C       COMPUTE PRESSURE HEADS TO USE IN FUNCTIONS
C
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      HCND(IN)=VSHKUVG(PTMP,J1)
      THETA(IN)=VSTHUVG(PTMP,J1)
      END IF
   10 CONTINUE
      RETURN
      else
      if(hydraulicFunctionType.eq.2) then
c
c       Haverkamp functions
c
      DO 11 J=2,NLYY
      DO 11 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      HCND(IN)=VSHKUHK(PTMP,J1)
      THETA(IN)=VSTHUHK(PTMP,J1)
      END IF
 11   CONTINUE
      RETURN
      else
c
c       Brooks-Corey functions
c
      if(hydraulicFunctionType.eq.0) then
      DO 12 J=2,NLYY
      DO 12 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      HCND(IN)=VSHKUBC(PTMP,J1)
      THETA(IN)=VSTHUBC(PTMP,J1)
      END IF
 12   CONTINUE
      RETURN
c
c       Tabular functions
c
      else
      if(hydraulicFunctionType.eq.3) then
      DO 13 J=2,NLYY
      DO 13 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      HCND(IN)=VSHKUTAB(PTMP,J1)
      THETA(IN)=VSTHUTAB(PTMP,J1)
      END IF
 13   CONTINUE
      RETURN
      else
c
c  user supplied other function type
c
      DO 14 J=2,NLYY
      DO 14 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
c
c  revisions for Rossi-Nimmo
c
c      HCND(IN)=VSHKUOT(PTMP,J1)
      THETA(IN)=VSTHUOT(PTMP,J1)
      HCND(IN) = VSHKUOT(THETA(IN),J1)
c
c  end revsions
c
      END IF
 14   CONTINUE
      RETURN
      end if
      end if
      end if
      end if
      END
      SUBROUTINE VSHCMP
C******
CVSHCMP
C******
C
C   PURPOSE: TO COMPUTE INTERCELL CONDUCTANCES
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_hcon.inc'
      include 'd_jtxx.inc'
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_hcon.inc'
c      include 'c_jtxx.inc'
c      include 'c_rprop.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
C
C----------------------------------------------------------------------
C
C    COMPUTE HARMONIC MEANS OF KSAT AND GRID SPACING
C
      DO 10 J=2,NLY
      DO 10 N=2,NXR
      IN=NLY*(N-1)+J
      JM1=IN-1
      NM1=IN-NLY
      A1=ANIZ(JTEX(IN))
      A2=ANIZ(JTEX(JM1))
      IF(HX(IN).EQ.0.0D0) GO TO 10
      AREA=DXR(N)
      IF(RAD)AREA=PI2*RX(N)*DXR(N)
C
C   VERTICAL CONDUCTANCE
C   THROUGH TOP
C
      HKTT(IN)=2.0D0*A1*A2*AREA*HX(IN)*HX(JM1)/(A2*HX(JM1)*DELZ(J)+
     &A1*HX(IN)*DELZ(J-1))
      AREA=DELZ(J)
      IF(RAD)AREA=PI2*DELZ(J)*(RX(N)-0.5D0 *DXR(N))
C
C   HORIZONTAL OR RADIAL CONDUCTANCE
C   THROUGH LEFT-HAND SIDE
C
      HKLL(IN)=2.0D0*AREA*HX(IN)*HX(NM1)/(HX(NM1)*DXR(N)+
     &HX(IN)*DXR(N-1))
   10 CONTINUE
      RETURN
      END
      SUBROUTINE VSFLUX
C******
CVSFLUX
C******
C
C      PURPOSE: TO COMPUTE FLUXES AND MASS BALANCE
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_dumm.inc'
      include 'd_jtxx.inc'
      include 'd_equat.inc'
      include 'd_trxx.inc'
      include 'd_trxy1.inc'
      include 'd_plott.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      include 'd_BF.inc'
      include 'd_ptet.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_jtxx.inc'
c      include 'c_equat.inc'
c      include 'c_trxx.inc'
c      include 'c_trxy1.inc'
c      include 'c_plott.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      integer hydraulicFunctionType, adsorptionType
      common/functiontype/ hydraulicFunctionType, adsorptionType
      character*11 label9(72,3)
      CHARACTER*80 TITL
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      common/elimit/elimit1,elimit2
      COMMON/MASSB/ BL(72),bcmft,bcmtt,bl29I,bl29IT,bl29O,bl29OT,
     1bl68I,bl68IT,bl68o,bl68OT,bl66T
      common/massb1/ bltemp36,bltemp39,bltemp42,bltemp45,bcmf,bcmt,
     1bltemp60
      common/massb2/ label9
C-------------------------------------------------------------------
C
C   INITIALIZE MASS BALANCE VARIABLES USED FOR
C   ENTIRE SIMULATION.
C
c
c  05/02 new variables created:
c   bcmf is water mass added to system by change in flow BC
c   bcmt is solute mass added to system by change in flow BC
c
      IF(KTIM.EQ.1) THEN
      DO 10 I=1,72
      BL(I)=0.0D0
   10 CONTINUE
      if (f7p) then
       do 11 i = 1,numBF
        totalBF(i,1) = 0.0d0
        totalBF(i,2) = 0.0d0
        currentBF(i,4) = 0.0d0
 11     continue
      end if
      bltemp36 = 0.0d0
      bltemp39 = 0.0d0
      bltemp42 = 0.0d0
      bltemp45 = 0.0d0
      bltemp60 = 0.0d0
      if (trans) then
      DO 15 J=2,NLYY
      DO 16 N=2,NXRR
      IN=(N-1)*NLY+J
      IF(HX(IN).NE.0.0D0) THEN
      VOL=DXR(N)*DELZ(J)
      IF(RAD)VOL=PI2*RX(N)*DXR(N)*DELZ(J)
      N2=JTEX(IN)
      if(adsorptionType.eq.2) then
       RETO=VTRETLG_MB(COLD(IN),N2)
      else
       if(adsorptionType.eq.3) then
        RETO=VTRETFR_MB(COLD(IN),N2)
       else
        if(adsorptionType.eq.4) then
         RETO=VTRETMM_MB(COLD(IN),N2)
        else
         if(adsorptionType.eq.5) then
          RETO=VTRETMD_MB(COLD(IN),N2)
         else
          if(adsorptionType.eq.6) then
           RETO=VTRETDM_MB(COLD(IN),N2)
          else
           if(adsorptionType.eq.7) then
            RETO=VTRETDD_MB(COLD(IN),N2)
           else
            RETO=VTRETFR_MB(COLD(IN),N2)
           end if
          end if
         end if
        end if
       end if
      end if
      BL(64)=BL(64)-RETO*VOL
      END IF
   16 continue
c      write(6,1616) j, in, reto, bl(64)
c 1616 format(' j = ',i5,'  in = ',i5,' reto = ',e13.5,' bl = ', e13.5)
   15 CONTINUE
      end if
      bcmft = 0.0d0
      bcmtt = 0.0d0
      bl29IT = 0.0d0
      bl29OT = 0.0d0
      bl68IT = 0.0d0
      bl68OT = 0.0d0
      bl66T = 0.0d0
c
c   label9 is array of headings for file 9 
c
      label9(1,1) = ' FLOW IN '
      LABEL9(2,1) = LABEL9(1,1)
      LABEL9(3,1) = LABEL9(1,1)
      LABEL9(4,1) = ' FLOW OUT '
      LABEL9(5,1) = LABEL9(4,1)
      LABEL9(6,1) = LABEL9(4,1)
      LABEL9(7,1) = LABEL9(1,1)
      LABEL9(8,1) = LABEL9(1,1)
      LABEL9(9,1) = LABEL9(1,1)
      LABEL9(10,1) = LABEL9(4,1)
      LABEL9(11,1) = LABEL9(4,1)
      LABEL9(12,1) = LABEL9(4,1)
      LABEL9(13,1) = ' TOTAL '
      LABEL9(14,1) = LABEL9(13,1)
      LABEL9(15,1) = LABEL9(13,1)
      LABEL9(16,1) = LABEL9(13,1)
      LABEL9(17,1) = LABEL9(13,1)
      LABEL9(18,1) = LABEL9(13,1)
      LABEL9(19,1) = ' EVAP- '
      LABEL9(20,1) = LABEL9(19,1)
      LABEL9(21,1) = LABEL9(19,1)
      LABEL9(22,1) = ' TRANS- '
      LABEL9(23,1) = LABEL9(22,1)
      LABEL9(24,1) = LABEL9(22,1)
      LABEL9(25,1) = ' EVAP + '
      LABEL9(26,1) = LABEL9(25,1)
      LABEL9(27,1) = LABEL9(25,1)
      LABEL9(28,1) = ' FLUID '
      LABEL9(29,1) = LABEL9(28,1)
      LABEL9(30,1) = LABEL9(28,1)
      LABEL9(31,1) = LABEL9(28,1)
      LABEL9(32,1) = LABEL9(28,1)
      LABEL9(33,1) = LABEL9(28,1)
      LABEL9(34,1) = ' SOLUTE IN '
      LABEL9(35,1) = LABEL9(34,1)
      LABEL9(36,1) = LABEL9(34,1)
      LABEL9(37,1) = ' SOLUTE OUT'
      LABEL9(38,1) = LABEL9(37,1)
      LABEL9(39,1) = LABEL9(37,1)
      LABEL9(40,1) = LABEL9(34,1)
      LABEL9(41,1) = LABEL9(34,1)
      LABEL9(42,1) = LABEL9(34,1)
      LABEL9(43,1) = LABEL9(37,1)
      LABEL9(44,1) = LABEL9(37,1)
      LABEL9(45,1) = LABEL9(37,1)
      LABEL9(46,1) = ' DISPERSION'
      LABEL9(47,1) = LABEL9(46,1)
      LABEL9(48,1) = LABEL9(46,1)
      LABEL9(49,1) = LABEL9(46,1)
      LABEL9(50,1) = LABEL9(46,1)
      LABEL9(51,1) = LABEL9(46,1)
      LABEL9(52,1) = ' TOTAL '
      LABEL9(53,1) = LABEL9(52,1)
      LABEL9(54,1) = LABEL9(52,1)
      LABEL9(55,1) = LABEL9(52,1)
      LABEL9(56,1) = LABEL9(52,1)
      LABEL9(57,1) = LABEL9(52,1)
      LABEL9(58,1) = ' SOLUTE OUT'
      LABEL9(59,1) = LABEL9(58,1)
      LABEL9(60,1) = LABEL9(58,1)
      LABEL9(61,1) = ' SOLUTE '
      LABEL9(62,1) = LABEL9(61,1)
      LABEL9(63,1) = LABEL9(61,1)
      LABEL9(64,1) = LABEL9(61,1)
      LABEL9(65,1) = LABEL9(61,1)
      LABEL9(66,1) = LABEL9(61,1)
      LABEL9(67,1) = LABEL9(61,1)
      LABEL9(68,1) = LABEL9(61,1)
      LABEL9(69,1) = LABEL9(61,1)
      LABEL9(70,1) = LABEL9(61,1)
      LABEL9(71,1) = LABEL9(61,1)
      LABEL9(72,1) = LABEL9(61,1)
C
      LABEL9(1,2) = ' SP HEAD '
      LABEL9(2,2) = LABEL9(1,2)
      LABEL9(3,2) = LABEL9(1,2)
      LABEL9(4,2) = LABEL9(1,2)
      LABEL9(5,2) = LABEL9(1,2)
      LABEL9(6,2) = LABEL9(1,2)
      LABEL9(7,2) = ' SP FLUX '
      LABEL9(8,2) = LABEL9(7,2)
      LABEL9(9,2) = LABEL9(7,2)
      LABEL9(10,2) = LABEL9(7,2)
      LABEL9(11,2) = LABEL9(7,2)
      LABEL9(12,2) = LABEL9(7,2)
      LABEL9(13,2) = ' FLOW IN '
      LABEL9(14,2) = LABEL9(13,2)
      LABEL9(15,2) = LABEL9(13,2)
      LABEL9(16,2) = ' FLOW OUT '
      LABEL9(17,2) = LABEL9(16,2)
      LABEL9(18,2) = LABEL9(16,2)
      LABEL9(19,2) = ' ORATION '
      LABEL9(20,2) = LABEL9(19,2)
      LABEL9(21,2) = LABEL9(19,2)
      LABEL9(22,2) = ' PIRATION '
      LABEL9(23,2) = LABEL9(22,2)
      LABEL9(24,2) = LABEL9(22,2)
      LABEL9(25,2) = ' TRANS '
      LABEL9(26,2) = LABEL9(25,2)
      LABEL9(27,2) = LABEL9(25,2)
      LABEL9(28,2) = ' STORAGE '
      LABEL9(29,2) = LABEL9(28,2)
      LABEL9(30,2) = LABEL9(28,2)
      LABEL9(31,2) = ' VOL BAL '
      LABEL9(32,2) = LABEL9(31,2)
      LABEL9(33,2) = LABEL9(31,2)
      LABEL9(34,2) = LABEL9(1,2)
      LABEL9(35,2) = LABEL9(1,2)
      LABEL9(36,2) = LABEL9(1,2)
      LABEL9(37,2) = LABEL9(1,2)
      LABEL9(38,2) = LABEL9(1,2)
      LABEL9(39,2) = LABEL9(1,2)
      LABEL9(40,2) = LABEL9(7,2)
      LABEL9(41,2) = LABEL9(7,2)
      LABEL9(42,2) = LABEL9(7,2)
      LABEL9(43,2) = LABEL9(7,2)
      LABEL9(44,2) = LABEL9(7,2)
      LABEL9(45,2) = LABEL9(7,2)
      LABEL9(46,2) = ' IN '
      LABEL9(47,2) = LABEL9(46,2)
      LABEL9(48,2) = LABEL9(46,2)
      LABEL9(49,2) = ' OUT '
      LABEL9(50,2) = LABEL9(49,2)
      LABEL9(51,2) = LABEL9(49,2)
      LABEL9(52,2) = LABEL9(34,1)
      LABEL9(53,2) = LABEL9(34,1)
      LABEL9(54,2) = LABEL9(34,1)
      LABEL9(55,2) = LABEL9(37,1)
      LABEL9(56,2) = LABEL9(37,1)
      LABEL9(57,2) = LABEL9(37,1)
      LABEL9(58,2) = ' ET '
      LABEL9(59,2) = LABEL9(58,2)
      LABEL9(60,2) = LABEL9(58,2)
      LABEL9(61,2) = ' DECAY '
      LABEL9(62,2) = LABEL9(61,2)
      LABEL9(63,2) = LABEL9(61,2)
      LABEL9(64,2) = ' ADSORPTION '
      LABEL9(65,2) = LABEL9(64,2)
      LABEL9(66,2) = LABEL9(64,2)
      LABEL9(67,2) = LABEL9(28,2)
      LABEL9(68,2) = LABEL9(28,2)
      LABEL9(69,2) = LABEL9(28,2)
      LABEL9(70,2) = ' MASS BAL '
      LABEL9(71,2) = LABEL9(70,2)
      LABEL9(72,2) = LABEL9(70,2)
      LABEL9(1,3) = ' TOTAL '
      LABEL9(2,3) = ' TIME STEP '
      LABEL9(3,3) = ' RATE '
      DO 771 K3 = 3,69,3
      LABEL9(K3+1,3) = LABEL9(1,3)
      LABEL9(K3+2,3) = LABEL9(2,3)
      LABEL9(K3+3,3) = LABEL9(3,3)
 771  CONTINUE
      END IF
C
C   INITIALIZE MASS BALANCE VARIABLES USED FOR CURRENT
C   TIME STEP
C
      BLTEMP=0.0D0
      BL(3)=0.0D0
      BL(6)=0.0D0
      BL(9)=0.0D0
      BL(12)=0.0D0
      BL(27)=0.0D0
      BL(29)=0.0D0
      BL(36)=0.0D0
      BL(39)=0.0D0
      BL(42)=0.0D0
      BL(45)=0.0D0
      BL(60)=0.0D0
      BL(68)=0.0D0
      BL(62)=0.0D0
      BL(51)=0.0D0
      BL(48)=0.0D0
      bcmf = 0.0D0
      bcmt = 0.0D0
      bltemp2 = 0.0D0
      bl29I = 0.0D0
      bl29O = 0.0D0
      bl68I = 0.0D0
      bl68O = 0.0D0
      if (f7p) then
       do 12 i=1,numBF
        currentBF(i,1) = 0.0d0
        currentBF(i,2) = 0.0d0
        currentBF(i,3) = 0.0d0
 12     continue
      end if
       DO 20 J=2,NLYY
      DO 20 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).EQ.0.0D0) GO TO 20
      JM1=IN-1
      JP1=IN+1
      NM1=IN-NLY
      NP1=IN+NLY
      VOL=DXR(N)*DELZ(J)
      IF(RAD)VOL=PI2*RX(N)*DXR(N)*DELZ(J)
C
C     SUM CHANGE IN STORAGE
C
      GSF=VOL*(THETA(IN)-THLST(IN))
      JJ=JTEX(IN)
      SS=HK(JJ,2)/HK(JJ,3)
      GSS=VOL*THETA(IN)*SS
      bltemp2 = (GSF+GSS*(P(IN)-PXXX(IN)))
      bl(29) = bl(29) + bltemp2
      if(bltemp2.ge.0.0d0) then
       if (.not.(ntyp(in).eq.1.and.jflag1.eq.1))
     1  bl29I = bl29I + bltemp2
       else
       if (.not.(ntyp(in).eq.1.and.jflag1.eq.1))
     1  bl29O = bl29O + bltemp2
      end if
      if(ntyp(in).eq.1.and.jflag1.eq.1) 
     1  bcmf = bcmf + bltemp2
      IF(TRANS) THEN
C
C   FOR TRANSPORT SUM CHANGE IN STORAGE AND DIFFUSIVE/DISPERSIVE
C   FLUXES
C
C     IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
C
C  CHANGE 8-12-91 FOR STORAGE
C
C    *CC(IN)*THETA(IN)*(1+SS*P(IN))-COLD(IN)*THLST(IN)*(1+SS*PXXX(IN)))
c      bltemp2 = VOL*(
c      IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
c     *CC(IN)*THETA(IN)*(2.0D0+SS*(P(IN)-PXXX(IN)))-CC(IN)*THLST(IN)-
c     &cold(in)*theta(in))
c
c*****************************
c following changes made 7-3-04 to correct way that dctheta/dt is
c calculated
c*****************************
      bltemp2 = VOL*(
     *CC(IN)*THETA(IN)*(1.0D0+SS*(P(IN)-PXXX(IN)))-COLD(IN)*THLST(IN))
c*****************************
      bl(68) = bl(68) + bltemp2
      if (jflag1.eq.1) then
c       if(ntyp(in).eq.1) bcmt = bcmt + cc(in)*(theta(in) - thlst(in))
c     &*vol
c       if(nctyp(in).eq.1) bcmt = bcmt + theta(in)*(cc(in) - cold(in))
c     &*vol
       if(ntyp(in).eq.1.or.nctyp(in).eq.1) bcmt = bcmt + bltemp2
      end if
      if(bltemp2.ge.0.0D0) then
       if (.not.((jflag1.eq.1).and.(ntyp(in).eq.1.or.nctyp(in).eq.1)))
     1   bl68I = bl68I + bltemp2
      else
       if (.not.((jflag1.eq.1).and.(ntyp(in).eq.1.or.nctyp(in).eq.1)))
     1   bl68O = bl68O + bltemp2
      end if 
c      IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
c     *CC(IN)*THETA(IN)*(1.0D0+SS*(P(IN)-PXXX(IN)))-COLD(IN)*THLST(IN))
C     SS=-HT(JJ,4)*(THETA(IN)+THETA(IN)*P(IN)*SS+RET(IN))*DELT
      SS=-HT(JJ,4)*(THETA(IN)+RET(IN))*DELT
      if(nctyp(in).ne.1) BL(62)=BL(62)+VOL*SS*CC(IN)
      if(adsorptionType.eq.2) then
       RETO=VTRETLG_MB(CC(IN),JJ)
      else
       if(adsorptionType.eq.3) then
        RETO=VTRETFR_MB(CC(IN),JJ)
       else
        if(adsorptionType.eq.4) then
         RETO=VTRETMM_MB(CC(IN),JJ)
        else
         if(adsorptionType.eq.5) then
          RETO=VTRETMD_MB(CC(IN),JJ)
         else
          if(adsorptionType.eq.6) then
           RETO=VTRETDM_MB(CC(IN),JJ)
          else
           if(adsorptionType.eq.7) then
            RETO=VTRETDD_MB(CC(IN),JJ)
           else
            RETO=VTRETFR_MB(CC(IN),JJ)
           end if
          end if
         end if
        end if
       end if
      end if
      BLTEMP=BLTEMP-RETO*VOL
      IF(NCTYP(IN).EQ.2) THEN
      IF(CS(IN).LT.0.0D0) THEN
      BL(51)=BL(51)+CS(IN)
      ELSE
      BL(48)=BL(48)+CS(IN)
      END IF
      END IF
      IF(NCTYP(IN).EQ.1) THEN
CM    IP2=NP1-1
CM    IM2=NM1+1
CM    IM3=NM1-1
CM    IP3=NP1+1
CM    T5=(DX1(NP1)*(CC(IN)-CC(NP1))-DX2(NP1)*(0.5D0)*(
CM   &CC(JP1)-CC(JM1)+CC(IP3)-CC(IP2)))
CM   &+(DX1(IN)*(CC(IN)-CC(NM1))+DX2(IN)*(0.5D0)*(
CM   &CC(JP1)-CC(JM1)+CC(IM2)-CC(IM3)))
CM   &+(DZ1(JP1)*(CC(IN)-CC(JP1))-DZ2(JP1)*(0.5D0)*(
CM   &CC(NP1)-CC(NM1)+CC(IP3)-CC(IM2)))
CM   &+(DZ1(IN)*(CC(IN)-CC(JM1))+DZ2(IN)*(0.5D0)*(
CM   &CC(NP1)-CC(NM1)+CC(IP2)-CC(IM3)))
CL
CL  FOLLOWING ADDED TO TRY TO FIX MASS BALANCE CALCULATIONS
CL  FOR CENTERED DIFFERENCING
CL
CM    T5O=(DX1(NP1)*(COLD(IN)-COLD(NP1))-DX2(NP1)*(0.5D0)*(
CM   &COLD(JP1)-COLD(JM1)+COLD(IP3)-COLD(IP2)))
CM   &+(DX1(IN)*(COLD(IN)-COLD(NM1))+DX2(IN)*(0.5D0)*(
CM   &COLD(JP1)-COLD(JM1)+COLD(IM2)-COLD(IM3)))
CM   &+(DZ1(JP1)*(COLD(IN)-COLD(JP1))-DZ2(JP1)*(0.5D0)*(
CM   &COLD(NP1)-COLD(NM1)+COLD(IP3)-COLD(IM2)))
CM   &+(DZ1(IN)*(COLD(IN)-COLD(JM1))+DZ2(IN)*(0.5D0)*(
CM   &COLD(NP1)-COLD(NM1)+COLD(IP2)-COLD(IM3)))
CM    T5=0.5D0*(T5+T5O)
CM
CM
CM  CHANGE ADDED 10-02-91
CM
      IF (CIT) THEN
       T5=A(IN)*(CC(IN)-CC(NM1))+ao(in)*(COLD(IN)-COLD(NM1))+
     &B(IN)*(CC(IN)-CC(JM1))+bo(in)*(COLD(IN)-COLD(JM1))+
     &C(IN)*(CC(IN)-CC(NP1))+co(in)*(COLD(IN)-COLD(NP1))+
     &D(IN)*(CC(IN)-CC(JP1))+do(in)*(COLD(IN)-COLD(JP1))
       ao(in) = a(in)
       bo(in) = b(in)
       co(in) = c(in)
       do(in) = d(in)
       IF(JFLAG1.EQ.1) THEN
        AO(IN)=0.5D0*AO(IN)
        BO(IN)=0.5D0*BO(IN)
        CO(IN)=0.5D0*CO(IN)
        DO(IN)=0.5D0*DO(IN)
       END IF
      ELSE
       T5=A(IN)*(CC(IN)-CC(NM1))+B(IN)*(CC(IN)-CC(JM1))+
     &C(IN)*(CC(IN)-CC(NP1))+D(IN)*(CC(IN)-CC(JP1))
      END IF
C#    T5=T5+0.5D0*(DX2(IN)*(CC(IM2)-CC(IM3))+DX2(NP1)*
C#   &(CC(IP2)-CC(IP3))+DZ2(IN)*(CC(IP2)-CC(IM3))+
C#   &DZ2(JP1)*(CC(IM2)-CC(IP3)))
CL
CL
CM
CM
      if (f7p) then
       do 14 ib1 = 1,numBF
       do 14 ib2 = 1,numcellsBF(ib1)
        if (in.eq.nodenum(ib1,ib2)) then
           currentBF(ib1,3) = currentBF(ib1,3) + T5
           go to 13
        end if
 14     continue
      end if
 13   continue
      IF(T5.LT.0.0D0) THEN
      BL(51)=BL(51)+T5
      ELSE
      BL(48)=BL(48)+T5
      END IF
      END IF
      END IF
C
C  FLUX FOR NEUMANN CELLS
C
      IF(NTYP(IN).EQ.2.or.ntyp(in).eq.7) THEN
      IF(QQ(IN).LE.0.0D0) THEN
      BL(12)=BL(12)+QQ(IN)
      IF(TRANS) BL(45)=BL(45)+QQ(IN)*CC(IN)
      ELSE
      BL(9)=BL(9)+QQ(IN)
      IF(TRANS) BL(42)=BL(42)+QQ(IN)*CS(IN)
      END IF
      ELSE
C
C   FLUX FOR DIRICHLET CELLS
C
      IF(NTYP(IN).EQ.1) THEN
c      IF(TRANS) THEN
c      QX=QT(IN)
c      ELSE
c      QX=VSFLX1(IN)
c      END IF
      if (.not. trans) qt(in) = vsflx1(in)
      qx = qt(in)
      IF(QX.LT.0.0D0) THEN
      BL(3)=BL(3)-QX
      IF(TRANS) BL(36)=BL(36)-QX*CS(IN)
      ELSE
      BL(6)=BL(6)-QX
      IF(TRANS) BL(39)=BL(39)-QX*CC(IN)
      END IF
      ELSE
C
C    SUM SOURCES AND SINKS
C
      BL(27)=BL(27)+Q(IN)
      if(NPV.ge.0) then
      IF(TRANS.AND.NTYP(IN).NE.5) BL(60)=BL(60)+Q(IN)*CC(IN)
      end if
      END IF
      END IF
   20 CONTINUE
C
C   ACCUMULATE VALUES FOR TOTAL ELAPSED SIMULATION TIME
C
      if (cit) then
       if(jflag1.eq.1) then
        bltemp36 = bl(36)
        bltemp39 = bl(39)
        bltemp42 = bl(42)
        bltemp45 = bl(45)
        bltemp60 = bl(60)
       else
        bltemp1 = 0.5d0*(bl(36)+bltemp36)
        bltemp36 = bl(36)
        bl(36) = bltemp1
        bltemp1 = 0.5d0*(bl(39)+bltemp39)
        bltemp39 = bl(39)
        bl(39) = bltemp1
        bltemp1 = 0.5d0*(bl(42)+bltemp42)
        bltemp42 = bl(42)
        bl(42) = bltemp1
        bltemp1 = 0.5d0*(bl(45)+bltemp45)
        bltemp45 = bl(45)
        bl(45) = bltemp1
        bltemp1 = 0.5d0*(bl(60)+bltemp60)
        bltemp60 = bl(60)
        bl(60) = bltemp1
       end if
      end if
      BL(24)=ETOUT
      BL(21)=ETOUT1
      BL(30)=BL(29)/DELT
      BL(15)=BL(3)+BL(9)
      BL(18)=BL(6)+BL(12)
      DO 30 I=2,26,3
      BL(I)=DELT*BL(I+1)
   30 CONTINUE
      BL(19)=BL(19)+BL(20)
      BL(22)=BL(22)+BL(23)
      BL(1)=BL(1)+BL(2)
      BL(4)=BL(4)+BL(5)
      BL(10)=BL(10)+BL(11)
      BL(13)=BL(13)+BL(14)
      BL(7)=BL(7)+BL(8)
      BL(16)=BL(16)+BL(17)
      BL(25)=BL(25)+BL(26)
      BL(28)=BL(28)+BL(29)
      BL(32)=BL(14)+BL(17)+BL(26)-BL(29) + bcmf
      BL(33)=BL(32)/DELT
      BL(31)=BL(31)+BL(32)
      bcmft = bcmft + bcmf
      bcmfr = bcmf/delt
      bl29IT = bl29IT + bl29I
      bl29OT = bl29OT + bl29O
      IF(TRANS) THEN
C
C   TRANSPORT MASS BALANCE COMPONENTS
C
      BL(67)=BL(67)+BL(68)
      BL(69)=BL(68)/DELT
      BL(61)=BL(61)+BL(62)
      BL(65)=BLTEMP-BL(64)
      BL(64)=BLTEMP
      BL(63)=BL(62)/DELT
      BL(66)=BL(65)/DELT
      BL(54)=BL(36)+BL(42)+BL(48)
      BL(57)=BL(39)+BL(45)+BL(51)
      DO 40 I=35,59,3
      BL(I)=DELT*BL(I+1)
   40 CONTINUE
      BL(49)=BL(49)+BL(50)
      BL(46)=BL(46)+BL(47)
      BL(58)=BL(58)+BL(59)
      BL(34)=BL(34)+BL(35)
      BL(37)=BL(37)+BL(38)
      BL(43)=BL(43)+BL(44)
      BL(52)=BL(52)+BL(53)
      BL(40)=BL(40)+BL(41)
      BL(55)=BL(55)+BL(56)
      BL(71)=BL(53)+BL(56)+BL(59)-BL(68)+BL(62)+BL(65) + bcmt
      BL(72)=BL(71)/DELT
      BL(70)=BL(70)+BL(71)
      bcmtt = bcmtt + bcmt
      bcmtr = bcmt/delt
      bl68IT = bl68IT + bl68I
      bl68OT = bl68OT + bl68O
      bl66T = bl66T + bl(65)
      END IF
C
C   WRITE RESULTS TO FILE 9
C
      IF(F9P) then
       if(ktim.eq.1) then
        if(o13p) then
         write(09,4002) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
         write(09,4002) '      ',(label9(mb9(im),2), im=1,nmb9)
         write(09,4002) '      ',(label9(mb9(im),3), im=1,nmb9)
        else
         write(09,4001) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
         write(09,4001) '      ',(label9(mb9(im),2), im=1,nmb9)
         write(09,4001) '      ',(label9(mb9(im),3), im=1,nmb9)
        end if
       end if
       if(.not.o9p.or.jplt.eq.1) then
        do 41 IM = 1,NMB9
         if(dabs(BL(MB9(IM))).lt.elimit1) then
          dum(IM) = elimit2
         else
          dum(IM) = BL(MB9(IM))
         end if
 41      continue
        if(o13p) then
c         WRITE(09,4003) STIM,(BL(MB9(IM)),IM=1,NMB9)
         WRITE(09,4003) STIM,(dum(IM),IM=1,NMB9)
        else
         WRITE(09,4000) STIM,(dum(IM),IM=1,NMB9)
c         WRITE(09,4000) STIM,(BL(MB9(IM)),IM=1,NMB9)
        end if
       end if
      end if
c
c  revision Aug 2008 to print boundary segment fluxes
c
      if(f7p) then
       if (ktim.eq.1) then
	  if (o13p) then
         write (7,4014)
	  else
         write (7,4011)
	  end if
       end if
       do 46 ib1 = 1,numBF
        iflag7 = 0
        do 45 ib2 = 1,numcellsBF(ib1)
         in1 = nodenum(ib1,ib2)
         if(ntyp(in1).eq.1) then
          iflag7 = 1
          qx = qt(in1)
          currentBF(ib1,1) = currentBF(ib1,1) - qx
          if (trans) then
           if (qt(in1).lt.0.0) then
            currentBF(ib1,2) = currentBF(ib1,2) - qx*cs(in1)
           else
            currentBF(ib1,2) = currentBF(ib1,2) - qx*cc(in1)
           end if
          end if
         else
          if (ntyp(in1).eq.2.or.ntyp(in1).eq.7) then
           iflag7 = 1
           currentBF(ib1,1) = currentBF(ib1,1) + qq(in1)
           if (trans) then
            if (qq(in1).lt.0.0) then
             currentBF(ib1,2) = currentBF(ib1,2) + qq(in1)*cc(in1)
            else
             currentBF(ib1,2) = currentBF(ib1,2) + qq(in1)*cs(in1)
            end if
           end if
          end if
         end if
 45     continue
        bl_flux = currentBF(ib1,1)*delt
        totalBF(ib1,1) = totalBF(ib1,1) + bl_flux
        if(nctyp(in1).eq.1.or.nctyp(in1).eq.2) iflag7 = 1
c
c  revision 10-15-10 for centered in time
c
        if (CIT) then
         if (jflag1.eq.1) then
          bl_mass = currentBF(ib1,2)
          currentBF(ib1,4) = bl_mass
          bl_mass = bl_mass + currentBF(ib1,3)
         else
          bltemp1 = currentBF(ib1,2)
          bl_mass = 0.5*(bltemp1 + currentBF(ib1,4)) + currentBF(ib1,3)
          currentBF(ib1,4) = bltemp1
         end if
        else
         bl_mass = currentBF(ib1,2) + currentBF(ib1,3)
        end if
        bltemp1 = bl_mass*delt
        totalBF(ib1,2) = totalBF(ib1,2) + bltemp1
c
c  end revision 10-15-10
c
c        bl_mass = currentBF(ib1,2)*delt
c        totalBF(ib1,2) = totalBF(ib1,2) + bl_mass
        if((iflag7.eq.1).and.(.not.o9p.or.jplt.eq.1)) then
         if(dabs(totalBF(ib1,1)).lt.elimit1)totalBF(ib1,1)=elimit2
         if(dabs(bl_flux).lt.elimit1) bl_flux = elimit2
         if(dabs(currentBF(ib1,1)).lt.elimit1)currentBF(ib1,1)=elimit2
         if(dabs(bltemp1).lt.elimit1)bltemp1 = elimit2
         if(dabs(bl_mass).lt.elimit1) bl_mass = elimit2
         if(dabs(totalBF(ib1,2)).lt.elimit1)totalBF(ib1,2)=elimit2
        if (o13p) then
         write(7,4013) stim,idBF(ib1),totalBF(ib1,1),bl_flux,
     1    currentBF(ib1,1),totalBF(ib1,2),bltemp1,bl_mass
        else
         write(7,4012) stim,idBF(ib1),totalBF(ib1,1),bl_flux,
     1    currentBF(ib1,1),totalBF(ib1,2),bltemp1,bl_mass
        end if   
        end if
 46     continue
      end if
c
c  end Aug 2008 revision
c
      IF(.NOT.F6P.AND.JPLT.NE.1.AND.JSTOP.NE.1.AND.JFLAG.NE.1) GO TO 50
C
C    WRITE RESULTS OF MASS BALANCE TO FILE 6
C
      do 47 m = 13,72
       if(dabs(bl(m)).lt.elimit1) bl(m) = elimit2
 47    continue
      WRITE (06,4010) KTIM,KP,STIM,TUNIT,ZUNIT,ZUNIT,ZUNIT,TUNIT,(BL(M),
     *M=1,12)
      WRITE(06,4020) (BL(M),M=13,27),bcmft,bcmf,bcmfr,(bl(m),m=28,33)
      IF(TRANS) WRITE(06,4030) CUNX,CUNX,CUNX,TUNIT,(BL(M),M=34,66),
     &bcmtt,bcmt,bcmtr,(BL(M), M=67,72)
      WRITE(06,4040)
   50 CONTINUE
      jflag1 = jflag
      RETURN
 4000 FORMAT(1pe14.6,73(1PE11.3))
 4003 FORMAT(1pe18.10,73(1PE21.13))
 4001 format(a14,1X,73a11)
 4002 format(a18,1X,73a21)
 4010 FORMAT(21X,10(1H-),1X,'MASS BALANCE SUMMARY FOR TIME STEP',
     & I9,1X,10(1H-)/25X,'RECHARGE PERIOD NUMBER ',I9/25X,
     &'TOTAL ELAPSED SIMULATION TIME = ',1PE14.6,1X,A4
     &//2X,128('+')/2X,'+',126X,'+'/
     &2X,'+',90X,' TOTAL THIS',10X,'RATE THIS',6X,'+'/2X,'+',
     &33X,'VOLUMETRIC FLOW BALANCE',
     &18X,'TOTAL   ',9X,'TIME STEP',11X,' TIME STEP',5X,'+'/
     &2X,'+',72X,A4,'**3',13X,A4,'**3',11X,A4,'**3/',A4,4X,'+'/
     &2X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD',
     &1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD',
     &1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES',
     &1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',11X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX',
     &1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+')
 4011 FORMAT('     TIME      BNDY    WATER      WATER      WATER',
     1'      SOLUTE     SOLUTE     SOLUTE'/,15X,'FACE     FLUX',
     2'       FLUX       FLUX       FLUX       FLUX       FLUX',/
     323X,'TOTAL      TIME STEP   RATE      TOTAL      TIME STEP',
     4'   RATE')
 4012 FORMAT(1pe14.6,i6,73(1PE11.3))
 4013 FORMAT(1pe18.10,i6,73(1PE21.13))
 4014 FORMAT(5x,'TIME',11x,'BNDY',4x,3('WATER',16x),1x,3('HEAT',17x),/
     120x,'FACE',5x,6('FLUX',17x),/,28x,2('TOTAL',16x,'TIME STEP',13x,
	2'RATE',16x))
 4020 FORMAT(1H ,1X,'+',40X,'TOTAL FLUX INTO DOMAIN --  ',2(1PE15.5,5X),
     & 1PE15.5,4X,'+'/2X,'+',38X,'TOTAL FLUX OUT OF DOMAIN --  ',
     &2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',51X,'EVAPORATION --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',49X,'TRANSPIRATION --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',38X,'TOTAL EVAPOTRANSPIRATION',
     &1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',30X,'      FLUID FROM BOUNDARY CHANGE --  ',
     &2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',30X,'CHANGE IN FLUID STORED IN DOMAIN --  ',
     &2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',42X,'FLUID VOLUME BALANCE'
     &,1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',126X,'+')
 4030 FORMAT(2X,'+',126X,'+',/,2X,'+',35X,'SOLUTE MASS BALANCE',
     &72X,'+',/,2X,'+',74X,A4,16X,A4,14X,A4,'/',A4,5X,'+',/,
     &2X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD',
     &1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD',
     &1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/
     &2x,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES --'
     &,'  ',
     &2(1PE15.5,5X),1PE15.5,4x,'+',/,2X,'+',11X,
     &'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES --  ',
     &2(1PE15.5,5X),1PE15.5,4X,'+'/,2X,'+',25X,
     &'DIFFUSIVE/DISPERSIVE FLUX INTO DOMAIN --  ',2(1PE15.5,5X),1PE15.5
     &,4X,'+'/2X,'+',23X,'DIFFUSIVE/DISPERSIVE FLUX OUT OF DOMAIN --',
     &1PE17.5,2(1PE20.5),4X,'+'/'  +',40X,'TOTAL FLUX INTO DOMAIN --',
     &1PE17.5,2(1PE20.5),4X,'+'/'  +',38X,'TOTAL FLUX OUT OF DOMAIN --',
     &1PE17.5,2(1PE20.5),4X,'+'/'  +',38X,'TOTAL EVAPOTRANSPIRATION --',
     &1PE17.5,2(1PE20.5),4X,'+'/'  +',45X,'FIRST ORDER DECAY --',
     &1PE17.5,2(1PE20.5),4X,'+'/'  +',39X,'ADSORPTION/ION EXCHANGE --',
     &1PE17.5,2(1PE20.5),4X,'+'/'  +',35X,'SOLUTE FROM BOUNDARY CHANGE',
     &' --',1PE17.5,2(1PE20.5),4X,'+'/
     &'  +',29X,'CHANGE IN SOLUTE STORED IN',
     &' DOMAIN --',1PE17.5,2(1PE20.5),4X,'+'/'  +',43X,
     &'SOLUTE MASS BALANCE --',1PE17.5,2(1PE20.5),4X,'+'/'  +',126X,'+')
 4040 FORMAT( 2X,128('+'))
      END
      DOUBLE PRECISION FUNCTION VSFLX1(IN)
C******
CVSFLX1
C******
C   PURPOSE: TO COMPUTE INTERCELL MASS FLUX RATES FOR DIRICHLET
C   BOUNDARY NODES
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_kcon.inc'
      include 'd_press.inc'
      include 'd_hcon.inc'
      include 'd_equat.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_kcon.inc'
c      include 'c_press.inc'
c      include 'c_hcon.inc'
c      include 'c_equat.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/WGT/WUS,WDS
C-----------------------------------------------------------------------
C
C
C   COMPUTE FLUXES ON ALL FOUR SIDES OF EACH CONSTANT HEAD NODE
C
      JM1=IN-1
      JP1=IN+1
      NP1=IN+NLY
      NM1=IN-NLY
C
C   COMPUTE A,B,C,D
C
      IF(WUS.EQ.0.0D0) THEN
      A(IN)=HKLL(IN)*DSQRT(HCND(NM1)*HCND(IN))
      B(IN)=HKTT(IN)*DSQRT(HCND(JM1)*HCND(IN))
      C(IN)=HKLL(NP1)*DSQRT(HCND(NP1)*HCND(IN))
      D(IN)=HKTT(JP1)*DSQRT(HCND(JP1)*HCND(IN))
      ELSE
      IF(P(NM1).GT.P(IN).AND.HX(NM1).NE.0.0D0) THEN
      ALA=WUS
      BTA=WDS
      ELSE
      ALA=WDS
      BTA=WUS
      END IF
      IF(P(JM1).GT.P(IN).AND.HX(JM1).NE.0.0D0) THEN
      ALB=WUS
      BTB=WDS
      ELSE
      ALB=WDS
      BTB=WUS
      END IF
      IF(P(NP1).GT.P(IN).AND.HX(NP1).NE.0.0D0) THEN
      ALC=WUS
      BTC=WDS
      ELSE
      ALC=WDS
      BTC=WUS
      END IF
      IF(P(JP1).GT.P(IN).AND.HX(JP1).NE.0.0D0) THEN
      ALD=WUS
      BTD=WDS
      ELSE
      ALD=WDS
      BTD=WUS
      END IF
C
C   DETERMINE FLUXES
C
      A(IN)=(ALA*HCND(NM1)+BTA*HCND(IN))*HKLL(IN)
      B(IN)=(ALB*HCND(JM1)+BTB*HCND(IN))*HKTT(IN)
      C(IN)=(ALC*HCND(NP1)+BTC*HCND(IN))*HKLL(NP1)
      D(IN)=(ALD*HCND(JP1)+BTD*HCND(IN))*HKTT(JP1)
      END IF
      if(ntyp(in).eq.1) then
       if(ntyp(nm1).eq.1) a(in) = 0.0d0
       if(ntyp(jm1).eq.1) b(in) = 0.0d0
       if(ntyp(np1).eq.1) c(in) = 0.0d0
       if(ntyp(jp1).eq.1) d(in) = 0.0d0
      end if
      QL=-A(IN)*(P(IN)-P(NM1))
      QA=-B(IN)*(P(IN)-P(JM1))
      QR=-C(IN)*(P(IN)-P(NP1))
      QB=-D(IN)*(P(IN)-P(JP1))
C
C    COMPUTE NET FLUX IN (+) OR OUT (-)
C
      VSFLX1=QL+QR+QA+QB
      RETURN
      END
      SUBROUTINE VSOUTP
C******
CVSOUTP
C******
C
C   PURPOSE: TO OUTPUT RESULTS AFTER EACH TIME STEP.
C
C-----------------------------------------------------------------------
C
C        SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_jtxx.inc'
      include 'd_dumm.inc'
      include 'd_trxx.inc'
      include 'd_plott.inc'
      include 'd_rprop.inc'
      include 'd_scon.inc'
      include 'd_disch.inc'
      IMPLICIT DOUBLE PRECISION(A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_jtxx.inc'
c      include 'c_dumm.inc'
c      include 'c_trxx.inc'
c      include 'c_plott.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
c      include 'c_disch.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      CHARACTER*80 TITL
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      common/elimit/elimit1,elimit2
C
C-------------------------------------------------------------------
C
C   OUTPUT RESULTS TO FILE 11 AT EACH TIME STEP
C
      IF(JSTOP.GT.1) RETURN
      if(.not.o11p.or.jplt.eq.1) then
      IF(F11P) THEN
      IF(.not.(TRANS.OR.VPNT).AND..NOT.SSTATE) CALL VTVELO
      DO 10 J=1,NOBS
      N=IJOBS(J)
      I=N/NLY+1
      J1=MOD(N,NLY)
      IF(HX(N).NE.0.0D0) THEN
       if(dabs(p(n)).lt.elimit1) p(n) = elimit2
       if(dabs(cc(n)).lt.elimit1) cc(n) = elimit2
       if(dabs(vx(n)).lt.elimit1) vx(n) = elimit2
       if(dabs(vz(n)).lt.elimit1) vz(n) = elimit2
       if(dabs(q(n)).lt.elimit1) q(n) = elimit2
      PPR=HK(JTEX(N),3)
      IF(PPR.EQ.0.0D0)PPR=1.0D0
      SAT=THETA(N)/PPR
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J1)
      ELSE
      Z1=DZZ(J1)*CS1+RX(I)*CS2
      END IF
      PHD=P(N)+Z1
      if (o13p) then
      IF(TRANS) THEN
      WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,CC(N),
     1 vx(n),vz(n),q(n)
      ELSE
      WRITE (11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,
     1 vx(n),vz(n),q(n)
      END IF
      else
      IF(TRANS) THEN
      WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,CC(N),
     1 vx(n),vz(n),q(n)
      ELSE
      WRITE (11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,
     1 vx(n),vz(n),q(n)
      END IF
      end if
      END IF
   10 CONTINUE
      end if
      END IF
      IF(KTIM.EQ.0)  GO TO 20
C
C    WRITE TIME STEP HEADER TO FILE 6
C
C    WRITE MAXIMUM HEAD CHANGE EACH TIME STEP TO FILE 7
C
c      IF(F7P) THEN
c      WRITE(07,4040) KTIM,STIM,NIT,NIT1
c      WRITE(07,4030) (DHMX(M2),M2=1,NIT)
c      END IF
      WRITE(06,4040) KTIM,STIM,NIT,NIT1
      IF(JSTOP.EQ.1.OR.JPLT.EQ.1) GO TO 20
      IF(.NOT.PRNT.AND.JFLAG.EQ.0) RETURN
   20 WRITE (6,4050) TITL,STIM,TUNIT,KTIM
C
C    PRINT SOLUTION FOR CURRENT TIME STEP
C
      IF(JPLT.EQ.1) THEN
c      if (f8p) then
C
C   WRITE PRESSURE HEADS TO FILE 8 AT OBSERVATION TIMES.
C
      WRITE (8,4000) STIM,TUNIT
      if (o12p) then
      if (trans) then
       write (12) stim, p, cc
      else
       write (12) stim, p
      end if
      end if
      DO 40 J=1,NLY
      DO 30 N=1,NXR
      IN=NLY*(N-1)+J
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      DUM(IN)=P(IN)+Z1
      if(dabs(dum(in)).lt.elimit1) dum(in) = elimit2
 30   continue
      if(o13p) then
       WRITE(8,4011) (DUM(N),N=J,NNODES-NLY+J,NLY)
      else
       WRITE(8,4010) (DUM(N),N=J,NNODES-NLY+J,NLY)
      end if
 40   continue
C
C  WRITE CONCENTRATIONS TO FILE 8
C
      IF(TRANS) THEN
      DO 50 J=1,NLY
      do 45 N=1,NXR
      IN = NLY*(N-1)+J
      DUM(IN) = CC(IN)
      if(dabs(dum(in)).lt.elimit1) dum(in) = elimit2
 45   continue
      if (o13p) then
       WRITE(08,4011) (DUM(N),N=J,NNODES-NLY+J,NLY)
      else
       WRITE(08,4010) (DUM(N),N=J,NNODES-NLY+J,NLY)
      end if
   50 CONTINUE
      END IF
c      end if
      END IF
C
C    PRINT TOTAL HEADS
C
      IF(HPNT) THEN
      WRITE (6,4060)
      CALL VSOUT(1,P)
      END IF
C
C  PRINT PRESSURE HEADS
C
      IF(PPNT) THEN
c      IF(JPLT.NE.1.or..not.f8p) THEN
      DO 60 J=2,NLYY
      DO 60 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      DUM(IN)=P(IN)+Z1
      IF(HX(IN).EQ.0.0D0)DUM(IN)=0.0D0
   60 CONTINUE
c      END IF
      WRITE (6,4070)
      CALL VSOUT(1,DUM)
      END IF
C
C  PRINT SATURATIONS
C
      IF(SPNT) THEN
      DO 70 J=2,NLYY
      DO 70 N=2,NXRR
      IN=NLY*(N-1)+J
      TTX=HK(JTEX(IN),3)
      IF(TTX.EQ.0.0D0) THEN
      DUM(IN)=0.0D0
      ELSE
      DUM(IN)=THETA(IN)/TTX
      END IF
   70 CONTINUE
      WRITE (6,4080)
      CALL VSOUT(2,DUM)
      END IF
C
C  PRINT MOISTURE CONTENTS
C
      IF(THPT) THEN
      WRITE (6,4090)
      CALL VSOUT(2,THETA)
      END IF
C
C  PRINT VELOCITIES
C
      IF(VPNT.AND.KTIM.GT.0) THEN
      if(nxr.gt.3) then
       WRITE(06,4100)
       CALL VSOUT(1,VX)
      end if
      if(nly.gt.3) then
       WRITE(06,4110)
       CALL VSOUT(1,VZ)
      end if
      END IF
C
C  PRINT CONCENTRATIONS
C
      IF(TRANS) THEN
      WRITE(6,4120)
      CALL VSOUT(1,CC)
      END IF
      CONTINUE
      RETURN
 4000 FORMAT(/,8H TIME = ,E15.6,1X,A4/)
 4010 FORMAT(99999(1PE15.7))
 4011 FORMAT(99999(1PE21.13))
 4020 FORMAT(1pe14.6,1x,i8,2x,12(1x,1PE12.5))
 4021 FORMAT(1pe18.10,1x,i8,2x,12(1PE21.13))
c
c following change made 6/29/09 for Marie S to print
c  3 digits in exponent
c
c 4020 FORMAT(1pe14.6,1x,i8,2x,12(1x,1PE12.4E3))
c 4021 FORMAT(1pe18.10,1x,i8,2x,12(1PE21.12E3))
 4030 FORMAT(7E11.4)
 4040 FORMAT(' TIME STEP ',I9,'  TIME = ',E14.6,'  NIT = ',I5,
     &'  NIT1 = ',I5)
 4050 FORMAT(6X,A80/5X,20HTOTAL ELAPSED TIME =,1PE14.6,1X,A4/5X,
     &10HTIME STEP ,I9,//)
 4060 FORMAT(1H ,50X,10HTOTAL HEAD)
 4070 FORMAT(1H ,50X,13HPRESSURE HEAD)
 4080 FORMAT(1H ,50X,10HSATURATION)
 4090 FORMAT(1H ,50X,16HMOISTURE CONTENT)
 4100 FORMAT(51X,'X-VELOCITY')
 4110 FORMAT(51X,'Z-VELOCITY')
 4120 FORMAT(51X,'CONCENTRATION')
      END
      SUBROUTINE VSOUT(IV,VPRNT)
C*****
CVSOUT
C*****
C
C    PURPOSE: TO PRINT TWO DIMENSIONAL ARRAYS
C
C
C-----------------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_dumm1.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_dumm1.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      CHARACTER*80 TITL
      CHARACTER*4 ZUNIT,TUNIT,CUNX
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX
      common/elimit/elimit1,elimit2
      DIMENSION VPRNT(1)
C
C-------------------------------------------------------------------
C
      include 'd_dumm1Alloc.inc'
      WRITE (06,4000) ZUNIT,ZUNIT
      WRITE (06,4010) (RX(K),K=2,NXRR)
      DO 30 J=2,NLYY
      DO 10 N=2,NXRR
      IN=NLY*(N-1)+J
      DUM1(N)=VPRNT(IN)
      IF(HX(IN).EQ.0.0D0) DUM1(N)=0.0D0
      if(dabs(dum1(n)).lt.elimit1) dum1(n) = elimit2
   10 CONTINUE
      IF(IV.GT.1) GO TO 20
      WRITE (06,4020) DZZ(J),(DUM1(N),N=2,NXRR)
      GO TO 30
   20 WRITE (06,4030) DZZ(J),(DUM1(N),N=2,NXRR)
   30 CONTINUE
      include 'd_dumm1Dealloc.inc'
      RETURN
 4000 FORMAT(1H ,1X,5HZ, IN/2X,A4,20X,20HX OR R DISTANCE, IN ,A4)
 4010 FORMAT(1H ,9X,99999(F11.3)/(9X,13(F9.2)))
 4020 FORMAT(1X,F9.3,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
 4030 FORMAT(1X,F9.3,99999(1X,F10.4)/(9X,13F9.3))
      END
      SUBROUTINE VSPOND(IFET,IFET1,IFET2)
C******
CVSPOND
C******
C
C  UPDATED 10-88
C
C    PURPOSE:  TO DETERMINE IF PONDING OR UNPONDING HAS OCCURRED, AND
C              IF SO TO CHANGE BOUNDARY CONDITIONS AT THOSE NODES FROM
C              NEUMAN TO DIRICHLET OR VICE VERSA
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_equat.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_equat.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/PND/POND
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
C
C--------------------------------------------------------------------
C
C   IFET1 INDICATES WHETHER THERE ARE ANY NEUMAN BOUNDARIES REMAINING
C   IFET2 INDICATES WHETHER ANY SPECIFIC FLUX NODES HAVE BEEN CONVERTED
C     TO SPECIFIED HEAD NODES.  BECAUSE OF THE CAPILLARY BARRIER
C     EFFECT, THESE NODES MAY NEED TO REVERT TO SPECIFIED FLUX NODES.
C   IFET INDICATES WHETHER PONDING OCCURRED OR DISAPPEARED
C
      IF(IFET1.EQ.0 .AND. IFET2 .EQ. 0) RETURN
      IFET=0
      IFET1=0
      IFET2=0
      IF(CS1.EQ.1.0D0) THEN
      DZ1=DZZ(2)
      ELSE
      IF(CS2.LT.0.0D0) THEN
      DZ1=DZZ(2)*CS1+RX(NXRR)*CS2
      ELSE
      DZ1=DZZ(2)*CS1+RX(2)*CS2
      END IF
      END IF
      DO 20 I=2,NXRR
      DO 10 J=2,NLYY
      IN=NLY*(I-1)+J
      IF(HX(IN).NE.0.0D0) THEN
      IF(NTYP(IN).EQ.2.AND.QQ(IN).GT.0.0D0) THEN
      IFET1=1
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      IF(POND.GE.0.0D0) THEN
C
C    DZ2 IS MAXIMUM ALLOWABLE TOTAL HEAD
C
      DZ2=POND-Z1
      ELSE
      DZ2=-DMIN1(Z1,DZ1-POND)
      END IF
      IF(P(IN).GT.DZ2) THEN
C
C    IF COMPUTED HEAD EXCEEDS MAXIMUM THEN SET P=DZ2
C    AND CHANGE BOUNDARY TYPE TO CONSTANT HEAD
C
      P(IN)=DZ2
      NTYP(IN)=1
      IFET=1
      IFET2=1
      WRITE(6,4000) J,I,KTIM,NIT
      END IF
      ELSE
      IF(NTYP(IN).EQ.1.AND.QQ(IN).GT.0.0D0) THEN
      IFET2=1
c
c  change 6/09 to prevent reconverting if p is not less
c   than DZ2
c
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      IF(POND.GE.0.0D0) THEN
C
C    DZ2 IS MAXIMUM ALLOWABLE TOTAL HEAD
C
      DZ2=POND-Z1
      ELSE
      DZ2=-DMIN1(Z1,DZ1-POND)
      END IF
      if (p(in).lt.DZ2) then
c
c  end 6/09 change
c
      JP1=IN+1
      IM1=IN+NLY
      IP1=IN-NLY
      TEST=(P(IN)-P(JP1))*D(IN)
      IF(HX(IM1).NE.0.0D0) TEST=TEST+(P(IN)-P(IM1))*C(IN)
      IF(HX(IP1).NE.0.0D0) TEST=TEST+(P(IN)-P(IP1))*A(IN)
      TEST=TEST/QQ(IN)
      IF (TEST .GE. 1.01D0)THEN
C
C  IF FLUX FROM THE CONVERTED NODE IS GREATER THAN THE SPECIFIED
C  FLUX RATE, THE NODE IS RECONVERTED TO A SPECIFIED FLUX NODE.
C
      NTYP(IN)=2
      IFET=1
      IFET1=1
      WRITE(06,4010)J,I,KTIM,NIT
      END IF
      end if
      END IF
      END IF
      GO TO 20
      END IF
   10 CONTINUE
   20 CONTINUE
      RETURN
 4000 FORMAT(//,6X,17H PONDING AT NODE ,2I5,17H DURING TIME STEP,
     &I9,'  ITERATION ',I5)
 4010 FORMAT(//,6X,' PONDING ENDED AT NODE ',2I5,
     &' DURING TIME STEP ',I9,'  ITERATION ',I5)
      END
      SUBROUTINE VSSFAC
C******
CVSSFAC
C******
C
C  REVISED 10-88
C
C    PURPOSE:  TO COMPUTE POSITION OF SEEPAGE FACE BOUNDARIES
C
C     HEIGHT OF SEEPAGE FACE IS LOWERED IF THERE IS FLUX INTO SYSTEM
C     THRU FACE.
C     HEIGHT IS RAISED IF PRESSURE HEADS ARE POSITIVE ABOVE FACE.
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_press.inc'
      include 'd_spfc.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_press.inc'
c      include 'c_spfc.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
C
C-------------------------------------------------------------------
C
      DO 90 K=1,NFCS
      NFX=NFC(K)
      JFST=0
      JLST=JLAST(K)
C
C   CHECK FOR POSITIVE PRESSURES ABOVE SEEPAGE FACE
C
      DO 10 J=NFX,1,-1
      IN=JSPX(1,J,K)
      JJ=JSPX(2,J,K)
      NN=JSPX(3,J,K)
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(JJ)
      ELSE
      Z1=DZZ(JJ)*CS1+RX(NN)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(PTMP.LT.0.0D0) GO TO 10
      JFST=J
      GO TO 20
   10 CONTINUE
   20 CONTINUE
C
C   CHECK FOR FLOW INTO DOMAIN THROUGH SEEPAGE FACE
C
      IF(JFST.GT.JLST) GO TO 60
      DO 40 I=JLST,1,-1
      IN=JSPX(1,I,K)
      IM1=IN-NLY
      JM1=IN-1
      IP1=IN+NLY
      JP1=IN+1
      IF(HX(IM1).EQ.0.0D0) THEN
      IF(HX(IP1).NE.0.0D0.AND.P(IP1).LT.P(IN)) GO TO 30
      END IF
      IF(HX(JM1).EQ.0.0D0) THEN
      IF(HX(JP1).NE.0.0D0.AND.P(JP1).LT.P(IN)) GO TO 30
      END IF
      IF(HX(IP1).EQ.0.0D0) THEN
      IF(HX(IM1).NE.0.0D0.AND.P(IM1).LT.P(IN)) GO TO 30
      END IF
      IF(HX(JP1).EQ.0.0D0) THEN
      IF(HX(JM1).NE.0.0D0.AND.P(JM1).LT.P(IN)) GO TO 30
      END IF
      GO TO 50
   30 NTYP(IN)=3
   40 CONTINUE
      I=0
   50 IF(I.EQ.JLST) GO TO 60
C
C   RESET SEEPAGE FACE HEIGHT AND BOUNDARIES
C
      JLAST(K)=I
      GO TO 80
   60 IF(JFST.EQ.JLST) GO TO 80
      DO 70 I=1,JFST
      IN=JSPX(1,I,K)
      JJ=JSPX(2,I,K)
      NN=JSPX(3,I,K)
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(JJ)
      ELSE
      Z1=DZZ(JJ)*CS1+RX(NN)*CS2
      END IF
      NTYP(IN)=1
      P(IN)=-Z1
   70 CONTINUE
      JLAST(K)=JFST
   80 CONTINUE
   90 CONTINUE
      END
      SUBROUTINE VSEVAP
C******
CVSEVAP
C******
C
C  PURPOSE: TO COMPUTE SURFACE EVAPORATION RATES
C
C
C------------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_hcon.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_ptet.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_hcon.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_ptet.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
C
C-----------------------------------------------------------------
C
      ETOUT1=0.0D0
      do 6 i = nly,nnodes
      q(i) = 0.0d0
 6    continue
      IF(SRES.EQ.0.0D0) RETURN
      DO 10 N=2,NXRR
      ETR = 0.0D0
      dzEvapCells = 0.0D0
      nIndex = nly*(n - 1)
      AREA=DXR(N)
      IF(RAD)AREA=PI2*RX(N)*DXR(N)
      PETT=PEV*AREA
      DO 7 J=2,NLYY
      IN = nIndex + J
      IF(NTYP(IN).EQ.5) then
        dzEvapCells = dzEvapCells + delz(j)
      end if
 7    continue
      DO 8 J=2,NLYY
      IN = nIndex + J
      IF(NTYP(IN).EQ.5) THEN
C
C    COMPUTE TEMPORARY EVAP RATE, CHECK AGAINST MAX AND
C    CORRECT IF NECESSARY
C
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      HKX=HCND(IN)*HX(IN)
      EV=HKX*SRES*(HA-PTMP)*AREA*delz(j)/dzEvapCells
      IF(EV.GT.0.0D0) EV=0.0D0
      Q(IN)=EV
      ETR = ETR + Q(IN)
      end if
 8    continue
      if (ETR.lt.pett) then
       r1 = pett/ETR
       ETR = PETT
       DO 9 J=2,NLYY
       IN = nIndex + J
       IF(NTYP(IN).EQ.5) q(in) = q(in)*r1
 9     continue
      end if
      ETOUT1=ETOUT1+ETR
   10 CONTINUE
      RETURN
      END
      SUBROUTINE VSPLNT
C******
CVSPLNT
C******
C
C   THIS SUBROUTINE COMPUTES ACTUAL ET AS A FUNCTION OF A ROOT
C        ACTIVITY FUNCTION, HYDRAULIC CONDUCTIVITY OF THE SOIL,
C        AND THE DIFFERENCE IN PRESSURE HEAD BETWEEN THE ROOTS AND
C        THE SOIL
C
C ----------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_hcon.inc'
      include 'd_ptet.inc'
      include 'd_dumm.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_press.inc'
c      include 'c_disch.inc'
c      include 'c_hcon.inc'
c      include 'c_ptet.inc'
c      include 'c_dumm.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
C
C   SUM TRANSPIRATION FOR EACH COLUMN
C
      ETOUT=0.0D0
      if(.not.bcit) then
      do 6 i = nly,nnodes
      q(i) = 0.0d0
 6    continue
      end if
      IF(PET.GE. 0.0D0)RETURN
      DO 50 I=2,NXRR
      ETR=0.0D0
      AREA=DXR(I)
      IF (RAD) AREA=PI2*RX(I)*DXR(I)
      PETT=AREA*PET
      iIndex = nly*(i-1)
      DO 10 J=2,NLYY
C
C   COMPUTE TRANSPIRATION FOR EACH NODE IN COLUMN
C
      IN=iIndex+J
      IF(NTYP(IN).EQ.0.AND.HX(IN).GT.0.0D0) THEN
      VOL=AREA*DELZ(J)
      IF(DPTH(IN).GT.RTDPTH) GO TO 20
C
C   TRANSPIRATION IS ZERO IF NTYP IS NOT 0, NODE IS DEEPER
C   THAN RTDPTH, OR PRESSURE IS LESS THAN HROOT
C
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(PTMP.LE.HROOT) THEN
      dum(IN)=0.0D0
      ELSE
      HXX=HCND(IN)*HX(IN)*RT(IN)*VOL
C
C   Q IS TRANSPIRATION FOR EACH NODE.  ETR IS TOTAL FOR COLUMN
C
      dum(IN)=(HROOT-PTMP)*HXX
      ETR=ETR+dum(IN)
      END IF
      END IF
   10 CONTINUE
 20   continue
      ETR1 = ETR
      IF(ETR.LT.PETT) THEN
C
C   IF TOTAL TRANSPIRATION FOR COLUMN IS GREATER
C   THAN POTENTIAL THEN ADJUST TRANSPIRATION VALUES
C
      R1=PETT/ETR
      ETR1=PETT
      end if
      DO 30 K=2,J
      IN=iIndex+K
      IF(HX(IN).GT.0.0D0.AND.NTYP(IN).EQ.0) THEN
      IF(DPTH(IN).GT.RTDPTH) GO TO 40
      if(etr.lt.pett) then
       Q(IN)= Q(IN) + dum(IN)*R1
      else
       Q(IN) = Q(IN) + dum(in)
      end if
      END IF
   30 CONTINUE
   40 CONTINUE
      ETOUT=ETOUT+ETR1
   50 CONTINUE
      RETURN
      END
      SUBROUTINE VSPET
C*****
CVSPET
C*****
C
C    PURPOSE: TO COMPUTE VALUES OF PEV,SRES,HA,PET,RTDPTH,RTBOT,RTTOP,
C             AND HROOT FOR EVAPORATION AND TRANSPIRATION CALCULATIONS.
C             VALUES ARE DETERMINED BY LINEAR INTERPOLATION IN TIME
C             BETWEEN EVAPOTRANSPIRATION PERIODS.
C
C------------------------------------------------------------------
C
C    SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_ptet.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_ptet.inc'
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
C
C---------------------------------------------------------------
C
      npv1 = npv
      if(npv.lt.0) npv = -npv
      IF (NPV.EQ.1) THEN
C
C   IF ONLY 1 PERIOD THEN ALL VALUES ARE CONSTANT
C
      IF(BCIT) THEN
      PEV=-PEVAL(1)
      SRES=RDC(1,1)
      HA=RDC(2,1)
      END IF
      IF(ETSIM) THEN
      PET=-PTVAL(1)
      RTDPTH=RDC(3,1)
      RTBOT=RDC(4,1)
      RTTOP=RDC(5,1)
      HROOT=RDC(6,1)
      END IF
      ELSE
C
C   DETERMINE WHICH PERIOD TO USE
C
      ETCYC1=NPV*ETCYC
      SITY=DMOD(STIM,ETCYC1)
      I=(SITY/ETCYC)+2
      if (i.gt.npv) i = 1
      IF(I.EQ.1) THEN
      K=NPV
      ELSE
      K=I-1
      END IF
C
C   LINEARLY INTERPOLATE
C
      FRPER=(DMOD(SITY,ETCYC))/ETCYC
      IF (BCIT) THEN
      PEV=-PEVAL(K)-(PEVAL(I)-PEVAL(K))*FRPER
      SRES=RDC(1,K)+(RDC(1,I)-RDC(1,K))*FRPER
      HA=RDC(2,K)+(RDC(2,I)-RDC(2,K))*FRPER
      END IF
      IF (ETSIM) THEN
      PET=-PTVAL(K)-(PTVAL(I)-PTVAL(K))*FRPER
      RTDPTH=RDC(3,K)+(RDC(3,I)-RDC(3,K))*FRPER
      RTBOT=RDC(4,K)+(RDC(4,I)-RDC(4,K))*FRPER
      RTTOP=RDC(5,K)+(RDC(5,I)-RDC(5,K))*FRPER
      HROOT=RDC(6,K)+(RDC(6,I)-RDC(6,K))*FRPER
      END IF
      END IF
      npv = npv1
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSRDF(Z1,Z2)
C*****
CVSRDF
C*****
C
C     PURPOSE: TO DETERMINE THE ROOT ACTIVITY AT EACH NODE WITHIN
C              THE ROOT ZONE FOR EACH TIME STEP
C
C
C--------------------------------------------------------------------
C
      include 'd_ptet.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_ptet.inc'
C
C------------------------------------------------------------
C
C
C   LINEARLY INTERPOLATE USING DEPTH OF NODE AND MAXIMUM ROOT DEPTH
C
      IF(RTDPTH.GT.Z1.AND.RTDPTH.GT.0.0D0)THEN
      IF(RTDPTH.GE.Z1+Z2)THEN
      ZZ=Z1+0.5D0*Z2
      ZZ1=1.0D0
      ELSE
      ZZ=(Z1+RTDPTH)*0.5D0
      ZZ1=(RTDPTH-Z1)/Z2
      END IF
      VSRDF=ZZ1*(ZZ*RTBOT+(RTDPTH-ZZ)*RTTOP)/RTDPTH
      ELSE
      VSRDF=0.0D0
      END IF
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSDTHUVG(P,I)
C ******
CVSDTHUVG
C******
C
C    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C
C   VAN GENUCHTEN FUNCTION
C
C          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
C          HK(I,2)=SPECIFIC STORAGE
C          HK(I,3)=POROSITY
C          HK(I,4)=ALPHA PRIME
C          HK(I,5)=RESIDUAL MOISTURE CONTENT
C          HK(I,6)=BETA PRIME
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSDTHUVG=0.0D0
      IF(P.GE.0.0D0)RETURN
      SE=HK(I,3)-HK(I,5)
      EN=HK(I,6)
      EM=2.0D0-1.0D0/EN
c
c   NOTE -- following change made 12/1/98 to change definition of van
c           Genuchten alpha from original definition used in VS2DT.
c           New definition corresponds to that given by van Genuchten
c           (1980) in terms of inverse length.
c
c      ALPH=HK(I,4)
      ALPH=-1.0D0/HK(I,4)
      A=P/ALPH
      VSDTHUVG=-(EN-1.0D0)*SE*A**(EN-1.0D0)/(ALPH*(1.0D0+A**EN)**EM)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVVG(V,I)
C******
CVSTHNVVG
C******
C
C    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
C    MOISTURE CONTENT
C
C    VAN GENUCHTEN FUNCTION
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
c      include 'c_rprop.inc'
      VSTHNVVG=0.0D0
      IF(V.GE.HK(I,3)) RETURN
      IF(V.GT.HK(I,5)) GO TO 10
      WRITE(6,4000) V,I
      jstop=6
      return
   10 SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
      EN=HK(I,6)
      EM=1.0D0-1.0D0/EN
c
c   NOTE -- following change made 12/1/98 to change definition of van
c           Genuchten alpha from original definition used in VS2DT.
c           New definition corresponds to that given by van Genuchten
c           (1980) in terms of inverse length.
c
c      ALPH=HK(I,4)
      ALPH=-1.0D0/HK(I,4)
      VSTHNVVG=ALPH*(1.0D0/SE**(1.0D0/EM)-1.0D0)**(1.0D0-EM)
      RETURN
 4000 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES'
     &,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/,
     &'PROGRAM HALTED')
      END
      DOUBLE PRECISION FUNCTION VSTHUVG(P,I)
C*****
CVSTHUVG
C*****
C
C    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C
C  VAN GENUCHTEN FUNCTION
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSTHUVG=HK(I,3)
      IF(P .GE. 0.0D0)RETURN
      EN=HK(I,6)
c     EM=-(1.0D0-1.0D0/EN)
      EM=(1.0D0-1.0D0/EN)
      A=HK(I,3)-HK(I,5)
c
c   NOTE -- following change made 12/1/98 to change definition of van
c           Genuchten alpha from original definition used in VS2DT.
c           New definition corresponds to that given by van Genuchten
c           (1980) in terms of inverse length.
c
c      ALPH=HK(I,4)
      ALPH=-1.0D0/HK(I,4)
      VSTHUVG=HK(I,5)+A/(1.0D0+(P/ALPH)**EN)**EM
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUVG(P,I)
C*****
CVSHKUVG
C*****
C
C    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
C
C   VAN GENUCHTEN FUNCTION
C
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSHKUVG=1.0D0
      IF(P.GE.0.0D0)RETURN
      EN=HK(I,6)
      EM=1.0D0-1.0D0/EN
c
c   NOTE -- following change made 12/1/98 to change definition of van
c           Genuchten alpha from original definition used in VS2DT.
c           New definition corresponds to that given by van Genuchten
c           (1980) in terms of inverse length.
c
c      A=P/HK(I,4)
      A=-P*HK(I,4)
      TOP=A**EN
      DEN=(1.0D0+TOP)**(EM/2.0D0)
c     TOP=1.0D0-TOP/A*(1.0D0+TOP)**(-EM)
      TOP=1.0D0-TOP/((1.0D0+TOP)**EM*A)
      VSHKUVG=TOP*TOP/DEN
      RETURN
      END

      DOUBLE PRECISION FUNCTION VSDTHUBC(P,I)
C******
CVSDTHUBC
C******
C
C    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C
C    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 17 PP.3-4
C
C          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
C          HK(I,2)=SPECIFIC STORAGE
C          HK(I,3)=POROSITY
C          HK(I,4)=BUBBLING PRESSURE
C          HK(I,5)=RESIDUAL MOISTURE CONTENT
C          HK(I,6)=LAMBDA
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSDTHUBC=0.0D0
      IF(P.GE.HK(I,4))RETURN
      VSDTHUBC=-((HK(I,3)-HK(I,5))*HK(I,6)*(HK(I,4)/P)**HK(I,6))/P
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVBC(V,I)
C******
CVSTHNVBC
C******
C
C    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
C    MOISTURE CONTENT
C
C    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 17 , PP.3-4
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
c      include 'c_rprop.inc'
      VSTHNVBC=HK(I,4)
      IF(V.GE.HK(I,3)) RETURN
      IF(V.GT.HK(I,5)) GO TO 1
      WRITE(6,100) V,I
  100 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES'
     1,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/,
     2'PROGRAM HALTED')
      jstop=6
      return
  1   SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
      VSTHNVBC=HK(I,4)/(SE**(1.0D0/HK(I,6)))
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHUBC(P,I)
C*****
CVSTHUBC
C*****
C
C    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD BELOW BUBBLING
C    PRESSURE: = POROSITY ELSEWHERE
C
C    BROOKS AND COREY, CSU HYDROLOGY PAPER NO.17, PP.3-4
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSTHUBC=HK(I,3)
      IF(P.GE.HK(I,4))RETURN
      VSTHUBC=HK(I,5)+(HK(I,3)-HK(I,5))*(HK(I,4)/P)**HK(I,6)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUBC(P,I)
C*****
CVSHKUBC
C*****
C
C    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
C
C    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 3
C
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSHKUBC=1.0D0
      IF(P.GE.HK(I,4))RETURN
      VSHKUBC=(HK(I,4)/P)**(2.0D0+3.0D0*HK(I,6))
      IF(VSHKUBC.LT.1.D-38)VSHKUBC=0.0D0
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSDTHUHK(P,I)
C******
CVSDTHUHK
C******
C
C    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C
C   HAVERKAMP FUNCTION
C
C          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
C          HK(I,2)=SPECIFIC STORAGE
C          HK(I,3)=POROSITY
C          HK(I,4)=A PRIME
C          HK(I,5)=RESIDUAL MOISTURE CONTENT
C          HK(I,6)=B PRIME
C          HK(I,7)=ALPHA
C          HK(I,8)=BETA
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSDTHUHK=0.0D0
      IF(P.GE.0.0D0)RETURN
      SE=HK(I,3)-HK(I,5)
      ALPH=HK(I,7)
      EM=HK(I,8)
      TOP=P/ALPH
      DEN=1.0D0+TOP**EM
      DEN=DEN*DEN
      VSDTHUHK=-SE*EM*TOP**(EM-1.0D0)/(ALPH*DEN)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVHK(V,I)
C******
CVSTHNVHK
C******
C
C    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
C    MOISTURE CONTENT
C
C    HAVERKAMP FUNCTION
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
c      include 'c_rprop.inc'
      VSTHNVHK=0.0D0
      IF(V.GE.HK(I,3)) RETURN
      IF(V.GT.HK(I,5)) GO TO 1
      WRITE(6,100) V,I
  100 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES'
     1,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/,
     2'PROGRAM HALTED')
      jstop=6
      return
  1   SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
      VSTHNVHK=HK(I,7)*(1.0D0/SE-1.0D0)**(1.0D0/HK(I,8))
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHUHK(P,I)
C******
CVSTHUHK
C******
C
C    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C
C  HAVERKAMP FUNCTION
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSTHUHK=HK(I,3)
      IF(P .GE. 0.0D0)RETURN
      VSTHUHK=HK(I,5)+(HK(I,3)-HK(I,5))/((P/HK(I,7))**HK(I,8)+1.0D0)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUHK(P,I)
C*****
CVSHKUHK
C*****
C
C    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
C
C  HAVERKAMP FUNCTION
C
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VSHKUHK=1.0D0
      IF(P.GE.0.0D0)RETURN
      VSHKUHK=1.0D0/((P/HK(I,4))**HK(I,6)+1.0D0)
      RETURN
      END
C **********************************************************************
C **********************************************************************
C
      SUBROUTINE INTERP (P,I)
C******
CINTERP
C******
C
C   THIS SUBROUTINE PERFORMS LINEAR INTERPOLATION OF PRESSURE
C   HEADS FOR RELATIVE HYDRAULIC CONDUCTIVITY (VSHKU), VOLUMETRIC
C   MOISTURE CONTENT (VSTHU), AND MOISTURE CAPACITY (VSDTHU).
C
C
C   TO USE THIS METHOD FOR EVALUATING THE NONLINEAR FUNCTIONS,
C   THE USER MUST ENTER A TABLE OF PRESSURE HEADS
C   AND VALUES OF RELATIVE
C   CONDUCTIVITIES,AND MOISTURE CONTENTS
C   WHICH CORRESPOND TO EACH PRESSURE HEAD INTO ARRAY HK ON
C   B-7 CARDS FOR EACH TEXTURAL CLASS.  SET NPROP (CARD B-5) EQUAL
C   TO 3*(NUMBER OF PRESSURE HEADS IN TABLE + 1).
C   BEGINNING WITH HK(ITEX,4), ENTER ALL PRESSURE HEADS IN DESCENDING
C   ORDER STARTING WITH THE HIGHEST VALUE,
C   NEXT ENTER THE NUMBER 99,
C   NEXT ENTER THE RELATIVE HYDRAULIC
C   CONDUCTIVITY FOR EACH PRESSURE HEAD,
C   NEXT ENTER THE NUMBER 99,
C   NEXT ENTER THE VOLUMETRIC MOISTURE CONTENT FOR EACH PRESSURE
C   HEAD, FINALLY ENTER THE NUMBER 99.
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      COMMON/hinterp/ DELP,nprop,I1,I2,I3,I4,I5,I6
c      IF (I2.GT.0) GO TO 1
      I2=4
      DO 2 J=I2,nprop
      IF (HK(I,J).LT.99.0D0) GO TO 2
      I3=J-I2+1
      I1=I3+I3
      GO TO 1
   2  CONTINUE
   1  IF(HK(I,I2).LE.P) THEN
      DELP=0.0D0
      I5=I2
      I6=I2
      ELSE
      I4=I2+I3-2
      IF(HK(I,I4).GE.P)THEN
      I5=I4-1
      I6=I4
      DELP=0.0D0
      ELSE
c      I4=I4-1
      DO 3 J=I2+1,I4
      IF(HK(I,J).GT.P) GO TO 3
      I5=J-1
      I6=J
      DELP=(P-HK(I,I6))/(HK(I,I5)-HK(I,I6))
      RETURN
   3  CONTINUE
      END IF
      END IF
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUTAB (P,I)
C*****
CVSHKUTAB
C*****
C
C   RELATIVE HYDRAULIC CONDUCTIVITY AS A FUNCTION OF PRESSURE HEAD
C   DETERMINED BY LINEAR INTERPOLATION OF KR VS HP TABLE WHICH IS
C   INPUT BY USER.
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      COMMON/hinterp/ DELP,nprop,I1,I2,I3,I4,I5,I6
      CALL INTERP (P,I)
      IF(I5.EQ.I6)THEN
      VSHKUTAB=HK(I,I3+I5)
      RETURN
      ELSE
      VSHKUTAB=HK(I,I3+I6)+(HK(I,I3+I5)-HK(I,I3+I6))*DELP
      RETURN
      END IF
      END
      DOUBLE PRECISION FUNCTION VSDTHUTAB(P,I)
C******
CVSDTHUTAB
C******
C
C   MOISTURE CAPACITY AS A FUNCTION OF PRESSURE HEAD AS
C   DETERMINED FROM TABLE OF THETA VS HP WHICH IS INPUT
C   BY USER.
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      COMMON/hinterp/ DELP,nprop,I1,I2,I3,I4,I5,I6
      CALL INTERP (P,I)
      IF (I5.EQ.I6) THEN
      VSDTHUTAB=0.0D0
      RETURN
      ELSE
      VSDTHUTAB=(HK(I,I1+I5)-HK(I,I1+I6))/(HK(I,I5)-HK(I,I6))
      RETURN
      END IF
      END
      DOUBLE PRECISION FUNCTION VSTHUTAB (P,I)
C*****
CVSTHUTAB
C*****
C
C   VOLUMETRIC MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C   AS DETERMINED BY LINEAR INTERPOLATION OF THETA VS HP TABLE
C   WHICH IS INPUT BY USER.
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      COMMON/hinterp/ DELP,nprop,I1,I2,I3,I4,I5,I6
      IF (DELP.EQ.0.0D0) THEN
      VSTHUTAB=HK(I,I1+I6)
      ELSE
      VSTHUTAB=HK(I,I1+I6)+(HK(I,I1+I5)-HK(I,I1+I6))*DELP
      END IF
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVTAB(P,I)
C******
CVSTHNVTAB
C******
C
C      NOTE -- THIS FUNCTION IS NOT OPERATIVE WHEN USING INTERPOLATION
C              ROUTINES.  INITIAL CONDITIONS MUST BE INPUT IN TERMS OF
C              PRESSURE HEADS NOT MOISTURE CONTENTS.
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
c      include 'c_rprop.inc'
      WRITE(6,100)
      jstop=7
      vsthnvtab=hk(i,3)
      return
  100 FORMAT(5X,'INPUT OF MOISTURE CONTENT FOR INITIAL CONDITIONS IS ',
     1'NOT ALLOWED WHEN USING TABULAR DATA '/
     25X,'FOR MOISTURE RETENTION AND CONDUCTIVITY CURVES',/
     35X,'SIMULATION TERMINATED')
      END

      DOUBLE PRECISION FUNCTION VSDTHUOT(P,I)
C******
CVSDTHUOT
C******
C     
c  modified for Rossi-Nimmo retention curve may 2006
c
C    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
C         USER-SUPPLIED FUNCTION
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      COMMON/JCON/JSTOP,JFLAG,jflag1
      vsdthuot=0.0D0
      h = -p
      if (h.le.0.0D0) then
       return
      else
       if (h.le.hk(i,7)) then
        vsdthuot = hk(i,3)*hk(i,8)*(h+h)/hk(i,4)**2.0D0
       else
        if (h.le.hk(i,10)) then
         vsdthuot = hk(i,3)*(hk(i,4)**hk(i,6))*hk(i,6)*h**(-1.0D0-hk(i,
     8          6))
        else
         vsdthuot = hk(i,3)*hk(i,9)/h
        end if
       end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVOT(V,I)
C******
CVSTHNVOT
C******
C
c  revised for Rossi-Nimmo 
c
C    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
C    MOISTURE CONTENT
C        USER-SUPPLIED FUNCTION

      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      vsthnvot=0.0D0
      p = V
      if (p.ge.hk(i,3)) then
       return
      else
       if (p.ge.hk(i,11)) then
        vsthnvot = -((hk(i,4)**(2.0D0))*((-p/hk(i,3) + 
     1     1.0D0)/hk(i,8)))**(.50D0)
       else
        if (p.ge.hk(i,12)) then
         vsthnvot = -(hk(i,4)**hk(i,6)*hk(i,3)/p)**(1.0D0/hk(i,6))
        else
         vsthnvot = -hk(i,5)*exp(-p/(hk(i,3)*hk(i,9)))
        end if
       end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHUOT(P,I)
C*****
CVSTHUOT
C*****
C
c  
c  revised for Rossi-Nimmo
c
C    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD BELOW BUBBLING
C    PRESSURE: = POROSITY ELSEWHERE
C         USER-SUPPLIED FUNCTION

      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      vsthuot=hk(i,3)
      h = -p
      if (h.le.0.0D0) then
       return
      else
       if (h.le.hk(i,7)) then
        vsthuot = hk(i,3)*(1.0D0 - hk(i,8)*(h/hk(i,4))**2.0D0)
       else
        if (h.le.hk(i,10)) then
         vsthuot = hk(i,3)*(hk(i,4)/h)**hk(i,6)
        else
         if (h.le.hk(i,5)) then
          vsthuot = hk(i,3)*hk(i,9)*log(hk(i,5)/h)
         else
          vsthuout = 0.0D0
        end if
       end if
      end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUOT(P,I)
C*****
CVSHKUOT
C*****
C
c  revised for Rossi-Nimmo
c
C    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
C      USER-SUPPLIED FUNCTION
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      vshkuot=1.0D0
      if (p.ge.hk(i,3)) then
       return
      else
       r1 = p/hk(i,3)
       if (p.lt.hk(i,12)) then
        xi3 = hk(i,9)*(exp(r1/hk(i,9)) - 1.0D0)/hk(i,5)
        vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
       else
        if (p.le.hk(i,11)) then
         xi3 = hk(i,18) + (r1**hk(i,14) - hk(i,15))/(hk(i,4)*hk(i,14))        
         vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        else
         xi3 = hk(i,19) + hk(i,16)*(hk(i,17) - (1.0D0 - r1)**(.50D0))
         vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        end if
       end if
      end if
      RETURN
      END
      SUBROUTINE VTVELO
C******
CVTVELO
C******
C
C    ROUTINE TO CALCULATE VELOCITIES AT BOUNDARIES OF ADJACENT CELLS
C    VX IS VELOCITY IN X-DIRECTION BETWEEN CURRENT NODE AND NODE TO
C    THE LEFT.
C    VZ IS VELOCITY IN Z-DIRECTION BETWEEN CURRENT NODE AND NODE
C    ABOVE.
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_hcon.inc'
      include 'd_trxx.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_press.inc'
c      include 'c_hcon.inc'
c      include 'c_trxx.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/WGT/WUS,WDS
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      DO 10 I=2,NXRR
      N1=NLY*(I-1)
      DO 10 J=2,NLYY
      N=N1+J
      VX(N)=0.0D0
      VZ(N)=0.0D0
      IF(HX(N).NE.0.0D0) THEN
      JM1=N-1
      IM1=N-NLY
      IF(HX(JM1).NE.0.0D0) THEN
C
C   CALCULATE VERTICAL VELOCITY
C
      if(ntyp(n).eq.1.and.ntyp(jm1).eq.1) then
       vz(n) = 0.0d0
      else
      AREA=DXR(I)
      IF (RAD) AREA=PI2*RX(I)*DXR(I)
      GRAD=P(JM1)-P(N)
      THETA1=0.5D0*(THETA(N)+THETA(JM1))*AREA
      IF(WUS.EQ.0.0D0) THEN
      VZ(N)=HKTT(N)*DSQRT(HCND(N)*HCND(JM1))*GRAD/THETA1
      ELSE
      IF(P(JM1).GT.P(N))THEN
      ALA=WUS
      BTA=WDS
      ELSE
      ALA=WDS
      BTA=WUS
      END IF
      VZ(N)=HKTT(N)*(ALA*HCND(JM1)+BTA*HCND(N))*GRAD/THETA1
      END IF
      END IF
      end if
      IF(HX(IM1).NE.0.0D0) THEN
C
C   CALCULATE HORIZONTAL VELOCITY
C
      if(ntyp(n).eq.1.and.ntyp(im1).eq.1) then
       vx(n) = 0.0d0
      else
      GRAD=P(IM1)-P(N)
      AREA=DELZ(J)
      IF (RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
      THETA1=0.5D0*(THETA(N)+THETA(IM1))*AREA
      IF(WUS.EQ.0.0D0) THEN
      VX(N)=HKLL(N)*DSQRT(HCND(N)*HCND(IM1))*GRAD/THETA1
      ELSE
      IF(P(IM1).GT.P(N)) THEN
      ALA=WUS
      BTA=WDS
      ELSE
      ALA=WDS
      BTA=WUS
      END IF
      VX(N)=HKLL(N)*(ALA*HCND(IM1)+BTA*HCND(N))*GRAD/THETA1
      END IF
      END IF
      END IF
      end if
   10 CONTINUE
      RETURN
      END
      SUBROUTINE VTDCOEF
C*******
CVTDCOEF
C*******
C
C    ROUTINE TO CALCULATE DISPERSION COEFFICIENTS AS FUNCTIONS
C    OF DISPERSIVITIES AND VELOCITIES.  DIAGNOL TERMS ARE
C    CONTAINED IN ARRAYS DX1 AND DZ1.  CROSS PRODUCT TERMS
C    ARE IN DX2 AND DZ2
C
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_jtxx.inc'
      include 'd_trxx.inc'
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_jtxx.inc'
c      include 'c_trxx.inc'
c      include 'c_rprop.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      DO 10 I=2,NXRR
      N1=NLY*(I-1)
      DO 10 J=2,NLYY
      N=N1+J
      DX1(N)=0.0D0
      DX2(N)=0.0D0
      DZ1(N)=0.0D0
      DZ2(N)=0.0D0
      PEX=0.0D0
      PEZ=0.0D0
      IMX=0
      JMX=0
      IMZ=0
      JMZ=0
      IF(HX(N).NE.0.0D0) THEN
      N2=JTEX(N)
      AL=HT(N2,1)
      AT=HT(N2,2)
      DM=HT(N2,3)
      V1=VX(N)
      V2=VZ(N)
      JM1=N-1
      IM1=N-NLY
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IF(HX(JM1).NE.0.0D0) THEN
      V3=0.25D0*(V1+VX(IP1)+VX(IP2)+VX(JM1))
      V32=V3*V3
      V22=V2*V2
      VV2=V32+V22
C
C   CALCULATE DZ1 AND DZ2
C
      N2=JTEX(JM1)
      AL1=DSQRT(AL*HT(N2,1))
      AT1=DSQRT(AT*HT(N2,2))
      DM1=DSQRT(DM*HT(N2,3))
      AREA=DXR(I)
      IF(RAD) AREA=PI2*AREA*RX(I)
      T1=0.5D0*(THETA(JM1)+THETA(N))
      DD1=(DZZ(J)-DZZ(J-1))/AREA
      T2=T1/DD1
      IF(VV2.EQ.0.0D0) THEN
      DZ1(N)=DM1
      ELSE
      VAVE=DSQRT(VV2)
      DL=AL1*VAVE
      DT=AT1*VAVE
      DZ1(N)=(DL*V22+DT*V32)/VV2+DM1
C#
      IF(HX(IP2).GT.0.0D0.AND.HX(IP1).GT.0.0D0) THEN
       IF(HX(IM1-1).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
        DD1=(RX(I+1)-RX(I-1))/AREA
       ELSE
        DD1=(RX(I+1)-RX(I))/AREA
       END IF
      ELSE
       IF(HX(IM1-1).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
        DD1=(RX(I)-RX(I-1))/AREA
       ELSE
        DD1=1.0D+14
       END IF
      END IF
C#
      DZ2(N)=T1*(DL-DT)*V2*V3/(DD1*VV2)
      END IF
C
C  CALCULATE VERTICAL CELL PECLET NUMBER
C
      IF(DZ1(N).LE.0.0D0) THEN
      PE=0.0D0
      ELSE
      PE=DABS(VZ(N))*(DZZ(J)-DZZ(J-1))/DZ1(N)
      END IF
      DZ1(N)=T2*DZ1(N)
      IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2.or.ntyp(n).eq.7) THEN
      IF(PE.GT.PEZ) THEN
      PEZ=PE
      IMZ=I
      JMZ=J
      END IF
      END IF
      END IF
      IF(HX(IM1).NE.0.0D0) THEN
      V3=0.25D0*(V2+VZ(JP1)+VZ(IM1)+VZ(IM2))
      V32=V3*V3
      V12=V1*V1
      VV2=V12+V32
C
C   CALCULATE DX1 AND DX2
C
      N2=JTEX(IM1)
      AL1=DSQRT(AL*HT(N2,1))
      AT1=DSQRT(AT*HT(N2,2))
      DM1=DSQRT(DM*HT(N2,3))
      AREA=DELZ(J)
      IF(RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
      DD1=(RX(I)-RX(I-1))/AREA
      T1=0.5D0*(THETA(IM1)+THETA(N))
      T2=T1/DD1
      IF(VV2.EQ.0.0D0) THEN
      DX1(N)=DM1
      ELSE
      VAVE=DSQRT(VV2)
      DL=AL1*VAVE
      DT=AT1*VAVE
      DX1(N)=(DL*V12+DT*V32)/VV2+DM1
C#
      IF(HX(JP1).GT.0.0D0.AND.HX(JP1-NLY).GT.0.0D0) THEN
       IF(HX(IM1-1).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
        DD1=(DZZ(J+1)-DZZ(J-1))/AREA
       ELSE
        DD1=(DZZ(J+1)-DZZ(J))/AREA
       END IF
      ELSE
       IF(HX(IM1-1).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
        DD1=(DZZ(J)-DZZ(J-1))/AREA
       ELSE
        DD1=1.0D+14
       END IF
      END IF
C#
      DX2(N)=T1*(DL-DT)*V1*V3/(VV2*DD1)
      END IF
C
C  CALCULATE HORIZONTAL CELL PECLET NUMBER
C
      IF(DX1(N).LE.0.0D0) THEN
      PE=0.0D0
      ELSE
      PE=DABS(VX(N))*(RX(I)-RX(I-1))/DX1(N)
      END IF
      DX1(N)=DX1(N)*T2
      IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2.or.ntyp(n).eq.7) THEN
      IF(PE.GT.PEX) THEN
      PEX=PE
      IMX=I
      JMX=J
      END IF
      END IF
      END IF
      END IF
   10 CONTINUE
C
C  WRITE MAXIMUM CELL PECLET NUMBERS
C
c      WRITE(6,4000) PEX,JMX,IMX,PEZ,JMZ,IMZ
      RETURN
c 4000 FORMAT(4X,'  MAXIMUM CELL PECLET NUMBER  --  HORIZONTAL  ',E14.5,
c     &'     ROW ',I4,'  COLUMN ',I4,/,38X,'VERTICAL    ',E14.5,
c     &'     ROW ',I4,'  COLUMN ',I4)
      END
      SUBROUTINE VTSETUP
C*******
CVTSETUP
C*******
C
C    ROUTINE TO ASSEMBLE MATRIX EQUATIONS FOR ADVECTION-DISPERSION
C    EQUATIONS AND TO CALL MATRIX SOLVER.
C
      include 'd_press.inc'
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_dumm.inc'
      include 'd_disch.inc'
      include 'd_equat.inc'
      include 'd_jtxx.inc'
      include 'd_trxx.inc'
      include 'd_trxy1.inc'
      include 'd_rprop.inc'
      include 'd_ptet.inc'
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_press.inc'
c      include 'c_rspac.inc'
c      include 'c_kcon.inc'
c      include 'c_mprop.inc'
c      include 'c_dumm.inc'
c      include 'c_disch.inc'
c      include 'c_equat.inc'
c      include 'c_jtxx.inc'
c      include 'c_trxx.inc'
c      include 'c_trxy1.inc'
c      include 'c_rprop.inc'
c      include 'c_scon.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      COMMON/JCON/JSTOP,JFLAG,jflag1
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      integer hydraulicFunctionType, adsorptionType
      common/functiontype/ hydraulicFunctionType, adsorptionType
      IF(jflag1.EQ.1) THEN
      DO 10 N=1,NNODES
      AO(N)=0.0D0
      BO(N)=0.0D0
      CO(N)=0.0D0
      DO(N)=0.0D0
      EO(N)=0.0D0
   10 CONTINUE
      END IF
C
C   INITIALIZE VARIABLES
C
      do 50 it=1,itmax
      DO 20 I=2,NXRR
      N1=NLY*(I-1)
      DO 20 J=2,NLYY
      N=N1+J
      A(N)=0.0D0
      B(N)=0.0D0
      C(N)=0.0D0
      D(N)=0.0D0
      E(N)=0.0D0
      RHS(N)=0.0D0   
      if(it.eq.1) then
       COLD(N)=CC(N)
       IF(NTYP(N).EQ.1) then
        dum(n) = qt(n)
        QT(N)=VSFLX1(N)
       else
        qt(n) = 0.0d0
       end if
c      end if
      IF(HX(N).NE.0.0D0) THEN
      N2=JTEX(N)
      if(SORP) then
      if(adsorptionType.eq.2) then
       RET(N)=VTRETLG(CC(N),N2)
      else
       if(adsorptionType.eq.3) then
        RET(N)=VTRETFR(CC(N),N2)
       else
        if(adsorptionType.eq.4) then
         RET(N)=VTRETMM(CC(N),N2)
        else
         if(adsorptionType.eq.5) then
          RET(N)=VTRETMD(CC(N),N2)
         else
          if(adsorptionType.eq.6) then
           RET(N)=VTRETDM(CC(N),N2)
          else
           if(adsorptionType.eq.7) then
            RET(N)=VTRETDD(CC(N),N2)
           else
            RET(N)=VTRETFR(CC(N),N2)
           end if
          end if
         end if
        end if
       end if
      end if
      else
       RET(N)=VTRETFR(CC(N),N2)
      end if
      end if
      end if
      if(HX(N).NE.0.0d0) THEN
      IM1=N-NLY
      JM1=N-1
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IM3=IM1-1
      IP3=IP1+1
      IF(RAD) THEN
      AREAX=PI2*DELZ(J)*(RX(I)-0.5D0*DXR(I))
      AREAX1=PI2*DELZ(J)*(RX(I)+0.5D0*DXR(I))
      AREAZ=PI2*DXR(I)*RX(I)
      ELSE
      AREAX=DELZ(J)
      AREAX1=AREAX
      AREAZ=DXR(I)
      END IF
      VOL=AREAZ*DELZ(J)
      AREAX=AREAX*0.5D0*(THETA(IM1)+THETA(N))
      AREAX1=AREAX1*0.5D0*(THETA(IP1)+THETA(N))
      AREAZ1=AREAZ*0.5D0*(THETA(JP1)+THETA(N))
      AREAZ=AREAZ*0.5D0*(THETA(JM1)+THETA(N))
C
C   CALCULATE LHS OF MATRIX EQUATION
C
      SS=THETA(N)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
      E(N)=-DX1(N)-DZ1(N)-DX1(IP1)-DZ1(JP1)
C    &-VOL*(HT(N2,4)*(THETA(N)+RET(N)))
C
C  CHANGE ADDED 8-12-91 TO CORRECT STORAGE TERM
C
      SS1=HT(N2,4)*(THETA(N)+RET(N))
c
c******************
c  following change made 7-3-04 to correct dctheta/dt 
c   calculation - see written notes
c
c******************
c      if(jflag1.ne.1.or.ntyp(n).ne.1) then
c       SS=THETA(N)+SS-THLST(N)
c      end if
c******************
C#
      A(N)=DX1(N)
      B(N)=DZ1(N)
      C(N)=DX1(IP1)
      D(N)=DZ1(JP1)
C#
      IF(HX(IM1).NE.0.0D0) THEN
C#    A(N)=DX1(N)+0.5*(+DZ2(N)-DZ2(JP1))
      IF(.NOT.CIS) THEN
      IF(VX(N).GT.0.0D0) THEN
      A(N)=A(N)+AREAX*VX(N)
      ELSE
      E(N)=E(N)+AREAX*VX(N)
      END IF
      ELSE
      VV=AREAX*0.5D0*VX(N)
      A(N)=A(N)+VV
      E(N)=E(N)+VV
      END IF
C#
      TEMP=0.5D0*DX2(N)
      IF(HX(IM3).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
       IF(HX(IM2).GT.0.0D0.AND.HX(JP1).GT.0.0D0) THEN
        B(N)=B(N)+TEMP
        D(N)=D(N)-TEMP
        RHS(N)=RHS(N)+TEMP*(CC(IM2)-CC(IM3))
       ELSE
        A(N)=A(N)-TEMP
        B(N)=B(N)+TEMP
        E(N)=E(N)-TEMP
        RHS(N)=RHS(N)-TEMP*CC(IM3)
       END IF
      ELSE
       IF(HX(IM2).GT.0.0D0.AND.HX(JP1).GT.0.0D0) THEN
        A(N)=A(N)+TEMP
        D(N)=D(N)-TEMP
        E(N)=E(N)+TEMP
        RHS(N)=RHS(N)+TEMP*CC(IM2)
       END IF
C#
      END IF
      END IF
      IF(HX(JM1).NE.0.0D0) THEN
C#    B(N)=DZ1(N)+0.5D0*(+DX2(N)-DX2(IP1))
      IF(.NOT.CIS) THEN
      IF(VZ(N).GT.0.0D0) THEN
      B(N)=B(N)+AREAZ*VZ(N)
      ELSE
      E(N)=E(N)+AREAZ*VZ(N)
      END IF
      ELSE
      VV=0.5D0*AREAZ*VZ(N)
      B(N)=B(N)+VV
      E(N)=E(N)+VV
      END IF
C#
      TEMP=0.5D0*DZ2(N)
      IF(HX(IP2).GT.0.0D0.AND.HX(IP1).GT.0.0D0) THEN
       IF(HX(IM3).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
        A(N)=A(N)+TEMP
        C(N)=C(N)-TEMP
        RHS(N)=RHS(N)+TEMP*(CC(IP2)-CC(IM3))
       ELSE
        B(N)=B(N)+TEMP
        C(N)=C(N)-TEMP
        E(N)=E(N)+TEMP
        RHS(N)=RHS(N)+TEMP*CC(IP2)
       END IF
      ELSE
       IF(HX(IM3).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
        A(N)=A(N)+TEMP
        B(N)=B(N)-TEMP
        E(N)=E(N)-TEMP
        RHS(N)=RHS(N)-TEMP*CC(IM3)
       END IF
      END IF
C#
      END IF
      IF(HX(IP1).NE.0.0D0) THEN
C#    C(N)=DX1(IP1)+0.5D0*(-DZ2(N)+DZ2(JP1))
      IF(.NOT.CIS) THEN
      IF(VX(IP1).LT.0.0D0) THEN
      C(N)=C(N)-AREAX1*VX(IP1)
      ELSE
      E(N)=E(N)-AREAX1*VX(IP1)
      END IF
      ELSE
      VV=0.5D0*AREAX1*VX(IP1)
      C(N)=C(N)-VV
      E(N)=E(N)-VV
      END IF
C#
      TEMP=0.5D0*DX2(IP1)
      IF(HX(JP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
       IF(HX(IP2).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
        B(N)=B(N)-TEMP
        D(N)=D(N)+TEMP
        RHS(N)=RHS(N)+TEMP*(CC(IP2)-CC(IP3))
       ELSE
        C(N)=C(N)-TEMP
        D(N)=D(N)+TEMP
        E(N)=E(N)-TEMP
        RHS(N)=RHS(N)-TEMP*CC(IP3)
       END IF
      ELSE
       IF(HX(IP2).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
        B(N)=B(N)-TEMP
        C(N)=C(N)+TEMP
        E(N)=E(N)+TEMP
        RHS(N)=RHS(N)+TEMP*CC(IP2)
       END IF
      END IF
C#
      END IF
      IF(HX(JP1).NE.0.0D0) THEN
C#    D(N)=DZ1(JP1)+0.5D0*(-DX2(N)+DX2(IP1))
      IF(.NOT.CIS) THEN
      IF(VZ(JP1).LT.0.0D0) THEN
      D(N)=D(N)-AREAZ1*VZ(JP1)
      ELSE
      E(N)=E(N)-AREAZ1*VZ(JP1)
      END IF
      ELSE
      VV=0.5D0*AREAZ1*VZ(JP1)
      D(N)=D(N)-VV
      E(N)=E(N)-VV
      END IF
C#
      TEMP=0.5D0*DZ2(JP1)
      IF(HX(IM2).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
       IF(HX(IP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
        A(N)=A(N)-TEMP
        C(N)=C(N)+TEMP
        RHS(N)=RHS(N)+TEMP*(CC(IM2)-CC(IP3))
       ELSE
        A(N)=A(N)-TEMP
        D(N)=D(N)+TEMP
        E(N)=E(N)+TEMP
        RHS(N)=RHS(N)+TEMP*CC(IM2)
       END IF
      ELSE
       IF(HX(IP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
        C(N)=C(N)+TEMP
        D(N)=D(N)-TEMP
        E(N)=E(N)-TEMP
        RHS(N)=RHS(N)-TEMP*CC(IP3)
       END IF
      END IF
C#
      END IF
      if (NPV.ge.0) then
      IF(Q(N).LT.0.0D0.AND.NTYP(N).NE.5) E(N)=E(N)+Q(N)
      end if
      IF(QQ(N).LT.0.0D0) E(N)=E(N)+QQ(N)
      IF(QT(N).GT.0.0D0) E(N)=E(N)-QT(N)
C
C  CENTERED-IN-TIME DIFFERENCING CAN BE USED ONLY AFTER THE
C  FIRST TIME STEP IN ANY RECHARGE PERIOD.
C
      IF(CIT.AND.JFLAG1.NE.1) THEN
      A(N)=0.5D0*A(N)
      B(N)=0.5D0*B(N)
      C(N)=0.5D0*C(N)
      D(N)=0.5D0*D(N)
      E(N)=0.5D0*E(N)
      END IF
      E(N)=E(N)-VOL*(SS1+(THETA(N)+SS+RET(N))/DELT)
      END IF
   20 CONTINUE
C
C  BEGIN LOOP TO CALCULATE RHS AND CALL MATRIX SOLVER
C
      DO 30 I=2,NXRR
      N1=NLY*(I-1)
      DO 30 J=2,NLYY
      N=N1+J
      IM1=N-NLY
      JM1=N-1
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IM3=IM1-1
      IP3=IP1+1
      IF(RAD) THEN
      VOL=PI2*DELZ(J)*DXR(I)*RX(I)
      ELSE
      VOL=DELZ(J)*DXR(I)
      END IF
      N2=JTEX(N)
      IF(SORP) THEN
      IF(IT.GT.1) THEN
C
C   FOR NONLINEAR SORPTION RECALCULATE RET,E
C
      RET1=RET(N)
      if(adsorptionType.eq.2) then
       RET(N)=VTRETLG(CC(N),N2)
      else
       if(adsorptionType.eq.3) then
        RET(N)=VTRETFR(CC(N),N2)
       else
        if(adsorptionType.eq.4) then
         RET(N)=VTRETMM(CC(N),N2)
        else
         if(adsorptionType.eq.5) then
          RET(N)=VTRETMD(CC(N),N2)
         else
          if(adsorptionType.eq.6) then
           RET(N)=VTRETDM(CC(N),N2)
          else
           if(adsorptionType.eq.7) then
            RET(N)=VTRETDD(CC(N),N2)
           else
            RET(N)=VTRETFR(CC(N),N2)
           end if
          end if
         end if
        end if
       end if
      end if
      IF(CIT.AND.JFLAG1.NE.1) THEN
      T1=0.5D0
      ELSE
      T1=1.0D0
      END IF
      E(N)=E(N)+VOL*(RET1-RET(N))*(1.0D0/DELT+HT(N2,4)*T1)
      END IF
      END IF
C
C   CALCULATE RHS OF MATRIX EQUATION
C
C
C  CHANGE ADDED 8-12-91 FOR STORAGE
C
C     RHS(N)=-VOL*(THETA(N)*(1.0D0+P(N)*HK(N2,2)/HK(N2,3))+RET(N))*COLD(N)/
C#    RHS(N)=-VOL*(THETA(N)+RET(N))*COLD(N)/
C#   &DELT+0.5D0*(DX2(N)*(+CC(IM2)-CC(IM3))+
C#   &DX2(IP1)*(CC(IP2)-CC(IP3))+DZ2(N)*(+CC(IP2)-CC(IM3))
C#   &+DZ2(JP1)*(CC(IM2)-CC(IP3)))-A(N)*CC(IM1)-B(N)*CC(JM1)
C#   &-C(N)*CC(IP1)-D(N)*CC(JP1)-E(N)*CC(N)
C#
c*************************
c  following change made 7-3-04 to correct dctheta/dt
c   calculation
c
c*************************
c      RHS(N)=RHS(N)-VOL*(THETA(N)+RET(N))*COLD(N)/DELT
      if (ntyp(n).eq.1) then
       RHS(N)=RHS(N)-VOL*(THETA(N)+RET(N))*COLD(N)/DELT
     &-A(N)*CC(IM1)-B(N)*CC(JM1)
     &-C(N)*CC(IP1)-D(N)*CC(JP1)-E(N)*CC(N)
      else
       RHS(N)=RHS(N)-VOL*(THLST(N)+RET(N))*COLD(N)/DELT
     &-A(N)*CC(IM1)-B(N)*CC(JM1)
     &-C(N)*CC(IP1)-D(N)*CC(JP1)-E(N)*CC(N)
      end if
C#
      IF (CIT.AND.JFLAG1.NE.1) RHS(N)=RHS(N)-AO(N)*COLD(IM1)-BO(N)
     **COLD(JM1)-CO(N)*COLD(IP1)-DO(N)*COLD(JP1)-EO(N)*COLD(N)
      IF(QQ(N).GT.0.0D0.and.ntyp(n).ne.1) RHS(N)=RHS(N)-QQ(N)*CS(N)
      IF(QT(N).LT.0.0D0.AND.NCTYP(N).EQ.0) then
       if (cit.and.jflag1.ne.1) then
        RHS(N)=RHS(N)+0.5d0*(QT(N)+dum(n))*CS(N)
       else
        rhs(n) = rhs(n)+qt(n)*cs(n)
       end if
      end if
      IF(QT(N).LE.0.0D0.AND.NCTYP(N).EQ.2) RHS(N)=RHS(N)-CS(N)
   30 CONTINUE
      NIT1=NIT1+1
C
C   CALL MATRIX SOLVER
C
      CALL SLVSIP
      IF(ITEST.EQ.0) THEN
      IF (CIT) THEN
      DO 40 I=2,NXRR
      N1=NLY*(I-1)
      DO 40 J=2,NLYY
      N=N1+J
      IF(HX(N).EQ.0.0D0) GO TO 40
      if(nctyp(n).ne.1) then
       AO(N)=A(N)
       BO(N)=B(N)
       CO(N)=C(N)
       DO(N)=D(N)
      end if
      IF(RAD) THEN
      AREAZ=PI2*DXR(I)*RX(I)
      ELSE
      AREAZ=DXR(I)
      END IF
      VOL=AREAZ*DELZ(J)
      N2=JTEX(N)
      SS=theta(n)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
C
C  CHANGE 8-12-91 FOR STORAGE
C
      SS1=HT(N2,4)*(THETA(N)+RET(N))
c
c****************
c  following change made 7-3-04 to correct dctheta/dt
c   calculation
c
c****************
c      if(jflag1.ne.1.or.ntyp(n).ne.1) then
c       SS=THETA(N)+SS-THLST(N)
c      end if
c****************
      EO(N)=E(N)+VOL*(SS1+(THETA(N)+SS+RET(N))/DELT)
      IF(JFLAG1.EQ.1) THEN
       if(nctyp(n).ne.1) then
        AO(N)=0.5D0*AO(N)
        BO(N)=0.5D0*BO(N)
        CO(N)=0.5D0*CO(N)
        DO(N)=0.5D0*DO(N)
       end if
       EO(N)=0.5D0*EO(N)
      END IF
   40 CONTINUE
      END IF
      RETURN
      END IF
   50 CONTINUE
      WRITE(6,4000)
      IF (.NOT.ITSTOP) RETURN
      JSTOP=10
      JFLAG=1
      WRITE(6,4010)
      RETURN
 4000 FORMAT(' MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR TRANSPORT'
     &,' EQUATION')
 4010 FORMAT(' Simulation terminated')
      END
      DOUBLE PRECISION FUNCTION VTRETLG(P,I)
C*****
CVTRETLG
C*****
C
C  SLOPE OF SORPTION ISOTHERM  --  LANGMUIR
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETLG=HT(I,5)*HT(I,6)*HT(I,7)/(1+HT(I,6)*P)**2
      RETURN
      end

      DOUBLE PRECISION FUNCTION VTRETLG_MB(P,I)
C*****
CVTRETLG_MB
C*****
C
C  SORPTION ISOTHERM  --  LANGMUIR - MB
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETLG_MB=HT(I,5)*HT(I,6)*HT(I,7)*P/(1+HT(I,6)*P)
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETFR(P,I)
C*****
CVTRETFR
C*****
C
C  SLOPE OF SORPTION ISOTHERM  --  FREUNDLICH
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      IF(HT(I,6).EQ.0.0D0) THEN
      VTRETFR=0.0D0
      RETURN
      END IF
      IF(HT(I,7).EQ.1.0D0) THEN
      VTRETFR=HT(I,5)*HT(I,6)
      ELSE
      IF (P.le.0.0D0) then
       VTRETFR = 0.0D0
      ELSE
      VTRETFR=HT(I,5)*HT(I,6)*HT(I,7)*P**(HT(I,7)-1.0D0)
      END IF
      END IF
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETFR_MB(P,I)
C*****
CVTRETFR_MB
C*****
C
C  SORPTION ISOTHERM  --  FREUNDLICH for MB
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      IF(HT(I,6).EQ.0.0D0) THEN
      VTRETFR_MB=0.0D0
      RETURN
      END IF
      if(p.le.0.0D0) then
       VTRETFR_MB = 0.0D0
      else
      IF(HT(I,7).EQ.1.0D0) THEN
      VTRETFR_MB=HT(I,5)*HT(I,6)*P
      ELSE
      VTRETFR_MB=HT(I,5)*HT(I,6)*P**HT(I,7)
      END IF
      END IF
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETMM(P,I)
C*****
CVTRETMM
C*****
C
C  SLOPE OF SORPTION CURVE FOR
C  MONOVALENT-MONOVALENT ION EXCHANGE
C
      include 'd_rprop.inc'

      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETMM=HT(I,5)*HT(I,6)*HT(I,7)*HT(I,8)/(P*(HT(I,6)-1.0D0)
     1+HT(I,8))**2
      RETURN
      end

       DOUBLE PRECISION FUNCTION VTRETMM_MB(P,I)
C*****
CVTRETMM_MB
C*****
C
C  SORPTION CURVE FOR
C  MONOVALENT-MONOVALENT ION EXCHANGE - MB
C
      include 'd_rprop.inc'

      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETMM_MB=HT(I,5)*HT(I,6)*HT(I,7)*P/(P*(HT(I,6)-1.0D0)
     1+HT(I,8))
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETDD(P,I)
C*****
CVTRETDD
C*****
C
C  Slope of SORPTION CURVE FOR
C  DIVALENT-DIVALENT ION EXCHANGE 
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETDD=HT(I,5)*HT(I,6)*HT(I,7)*HT(I,8)/((P+P)*
     1(HT(I,6)-1.0D0)+HT(I,8))**2
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETDD_MB(P,I)
C*****
CVTRETDD_MB
C*****
C
C  SORPTION CURVE FOR
C  DIVALENT-DIVALENT ION EXCHANGE - MB
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETDD_MB=HT(I,5)*HT(I,6)*HT(I,7)*P/((P+P)*
     1(HT(I,6)-1.0D0)+HT(I,8))
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETMD(P,I)
C*****
CVTRETMD
C*****
C
C  SLOPE OF SORPTION CURVE FOR
C  MONOVALENT-DIVALENT ION EXCHANGE
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      IF(P.LE.0.0D0) THEN
      VTRETMD=0.0D0
      ELSE
      P1=P*P
      P2=P1*HT(I,6)
      P3=HT(I,8)-P
      P3=P3+P3
      P4=HT(I,6)*(P+P)
      CB=(-P2+DSQRT(P2*P2+(P3+P3)*P2*HT(I,7)))/P3
      IF(CB.LT.HT(I,7))THEN
      VTRETMD=HT(I,5)*(CB*CB+P4*(HT(I,7)-CB))/(P3*CB+P2)
      ELSE
      VTRETMD=HT(I,5)*(HT(I,7)*HT(I,7))/(P3*HT(I,7)+P2)
      END IF
      END IF
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETMD_MB(P,I)
C*****
CVTRETMD_MB
C*****
C
C  SORPTION CURVE FOR
C  MONOVALENT-DIVALENT ION EXCHANGE - MB
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      IF(P.LE.0.0D0) THEN
      VTRETMD_MB=0.0D0
      ELSE
      P1=P*P
      P2=P1*HT(I,6)
      P3=HT(I,8)-P
      P3=P3+P3
      P4=HT(I,6)*(P+P)
      CB=(-P2+DSQRT(P2*P2+(P3+P3)*P2*HT(I,7)))/P3
      IF(CB.LT.HT(I,7))THEN
      VTRETMD_MB = HT(I,5)*CB
      ELSE
      VTRETMD_MB = HT(I,5)*HT(I,7)
      END IF
      END IF
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETDM(P,I)
C*****
CVTRETDM
C*****
C
C  SLOPE OF SORPTION CURVE FOR
C  DIVALENT-MONOVALENT ION EXCHANGE
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      IF(P.LE.0.0D0) THEN
      VTRETDM=0.0D0
      ELSE
      IF((P+P).GE.HT(I,8)) THEN
      VTRETDM=0.0D0
      ELSE
      P1=P*HT(I,6)
      P2=P1+P1+P1+P1
      P4=HT(I,8)-P-P
      P5=P4*P4
      P6=HT(I,7)**2
      P3=-P2*HT(I,7)-P5
      P7=P3*P3-4*P2*P1*P6
      IF (P7.GT.0.0D0) THEN
      CB=(-P3-DSQRT(P7))/(P2+P2)
      ELSE
      CB=0.0D0
      END IF
      VTRETDM=HT(I,5)*(-CB*CB*4*HT(I,6)+4.0D0*CB*(HT(I,6)*HT(I,7)-P4)-
     &HT(I,6)*P6)/(P2*(CB+CB-HT(I,7))-P5)
      END IF
      END IF
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETDM_MB(P,I)
C*****
CVTRETDM_MB
C*****
C
C  SORPTION CURVE FOR
C  DIVALENT-MONOVALENT ION EXCHANGE - MB
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      IF(P.LE.0.0D0) THEN
      VTRETDM_MB=0.0D0
      ELSE
      IF((P+P).GE.HT(I,8)) THEN
      VTRETDM_MB=0.0D0
      ELSE
      P1=P*HT(I,6)
      P2=P1+P1+P1+P1
      P4=HT(I,8)-P-P
      P5=P4*P4
      P6=HT(I,7)**2
      P3=-P2*HT(I,7)-P5
      P7=P3*P3-4*P2*P1*P6
      IF (P7.GT.0.0D0) THEN
      CB=(-P3-DSQRT(P7))/(P2+P2)
      ELSE
      CB=0.0D0
      END IF
      VTRETDM_MB=HT(I,5)*CB
      END IF
      END IF
      RETURN
      END

      DOUBLE PRECISION FUNCTION VTRETOT(P,I)
C*****
CVTRETOT
C*****
C
C  SLOPE OF SORPTION CURVE FOR
C  USER-SUPPLIED ADSORPTION MODEL
C
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rprop.inc'
      VTRETOT=0.0D0
      RETURN
      END

      SUBROUTINE vsgrav_dr
C******
CVSgrav_dr
C******
C
C  PURPOSE: TO COMPUTE flows from gravity drainage boundaries
C
C
C------------------------------------------------------------------
C
C   SPECIFICATIONS FOR ARRAYS AND SCALARS
C
      include 'd_kcon.inc'
      include 'd_hcon.inc'
      include 'd_disch.inc'
      include 'd_press.inc'
      include 'd_rspac.inc'
      include 'd_trxx.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_kcon.inc'
c      include 'c_hcon.inc'
c      include 'c_disch.inc'
c      include 'c_press.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
C
C-----------------------------------------------------------------
C
      DO 10 J=2,NLYY
      DO 10 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(NTYP(IN).EQ.7) then
        AREA=DXR(N)
        IF(RAD)AREA=PI2*RX(N)*DXR(N)
        qq(in) = -hx(in)*hcnd(in)*AREA
      END IF
   10 CONTINUE
      RETURN
      END



C
C   Following are subroutines that are required for connecting
C   VS2DT fortran program to VS2DTI post processor
C
      SUBROUTINE GETNX(NX)
C *** GET THE NUMBER OF CELLS IN THE X DIRECTION
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      NX = NXR
      RETURN
      END

      SUBROUTINE GETNZ(NZ)
C *** GET THE NUMBER OF CELLS IN THE Z DIRECTION
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      NZ = NLY
      RETURN
      END

      SUBROUTINE GETDX(DX, NX)
C *** GET THE CELL SIZES IN THE X DIRECTION AND RETURN IT IN THE
C *** ARRAY DX PROVIDED BY THE CALLING PROGRAM
      include 'd_rspac.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
      DIMENSION DX(NX)
      DO 10 I=1, NX
         DX(I) = DXR(I)
  10  CONTINUE
      RETURN
      END

      SUBROUTINE GETDZ(DZ, NZ)
C *** GET THE CELL SIZES IN THE Z DIRECTION AND RETURN IT IN THE
C *** ARRAY DZ PROVIDED BY THE CALLING PROGRAM
      include 'd_rspac.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_rspac.inc'
      DIMENSION DZ(NZ)
      DO 10 I=1, NZ
         DZ(I) = DELZ(I)
  10  CONTINUE
      RETURN
      END

      SUBROUTINE GETCONC(C, NC)
C *** GET THE CONCENTRATION ARRAY AND PUT IT IN C, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_trxx.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_trxx.inc'
      DIMENSION C(NC)
      DO 10 I=1,NC
         C(I) = CC(I)
   10 CONTINUE
      RETURN
      END

      SUBROUTINE GETKSAT(HX1, NN)
C *** GET THE SATURATED HYDRAULIC CONDUCTIVITY AND RETURN IT IN HX1, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_kcon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_kcon.inc'
      DIMENSION HX1(NN)
      DO 10 I=1,NN
         HX1(I) = HX(I)
   10 CONTINUE
      RETURN
      END

      SUBROUTINE GETTEX(JT, NN)
C *** GET THE TEXTURAL CLASS MAP AND RETURN IT IN JT, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_jtxx.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_jtxx.inc'
      DIMENSION JT(NN)
      DO 10 I=1,NN
         JT(I) = JTEX(I)
   10 CONTINUE
      RETURN
      END
      SUBROUTINE GETMOIST(THETA1, NN)
C *** GET THE MOISTURE CONTENTS AND RETURN IT IN THETA1, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_mprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_mprop.inc'
      DIMENSION THETA1(NN)
      DO 10 I=1,NN
         THETA1(I) = THETA(I)
   10 CONTINUE
      RETURN
      END

      SUBROUTINE GETSAT(SAT, NN)
C *** GET THE SATURATION AND RETURN IT IN SAT, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_mprop.inc'
      include 'd_jtxx.inc'
      include 'd_rprop.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_mprop.inc'
c      include 'c_jtxx.inc'
c      include 'c_rprop.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      DIMENSION SAT(NN)
      DO 70 J=2,NLYY
        DO 70 N=2,NXRR
          IN=NLY*(N-1)+J
          TTX=HK(JTEX(IN),3)
          IF(TTX.EQ.0.0D0) THEN
            SAT(IN)=0.0D0
          ELSE
            SAT(IN)=THETA(IN)/TTX
          END IF
   70 CONTINUE
      RETURN
      END

      SUBROUTINE GETPHEAD(PHEAD, NN)
C *** GET THE PRESSURE HEAD AND RETURN IT IN PHEAD, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_press.inc'
      include 'd_rspac.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_press.inc'
c      include 'c_rspac.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      DIMENSION PHEAD(NN)
      DO 70 J=1,NLY
        DO 70 N=1,NXR
          IN=NLY*(N-1)+J
          IF(CS1.EQ.1.0D0) THEN
            Z1=DZZ(J)
          ELSE
            Z1=DZZ(J)*CS1+RX(N)*CS2
          END IF
          PHEAD(IN) = P(IN)+Z1
   70 CONTINUE
      RETURN
      END

      SUBROUTINE GETSTIME(STIME)
C *** GET THE SIMULATION TIME AND RETURN IT IN STIME
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      STIME = STIM
      RETURN
      END

      SUBROUTINE GETSTEP(KTIME)
C *** GET THE TIME STEP AND RETURN IT IN KTIME
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      KTIME = KTIM
      RETURN
      END

      SUBROUTINE CLOSEIO
C *** CLOSE ALL IO UNITS
      CLOSE(2)
      CLOSE(5)
      CLOSE(6)
      CLOSE(7)
      CLOSE(8)
      CLOSE(9)
      CLOSE(10)
      CLOSE(11)
      CLOSE(12)
      CLOSE(13)
      RETURN
      END

      SUBROUTINE RELEASEMEMORY
      include 'd_rspac.inc'
      include 'd_kcon.inc'
      include 'd_mprop.inc'
      include 'd_press.inc'
      include 'd_disch.inc'
      include 'd_hcon.inc'
      include 'd_equat.inc'
      include 'd_jtxx.inc'
      include 'd_dumm.inc'
      include 'd_dumm1.inc'
      include 'd_ptet.inc'
      include 'd_trxx.inc'
      include 'd_trxy1.inc'
      include 'd_pit.inc'
      include 'd_sip.inc'
      include 'd_idumm.inc'
      include 'd_plott.inc'
      include 'd_rprop.inc'
      include 'd_spfc.inc'
      include 'd_scon.inc'
      include 'd_ptet.inc'
      include 'd_BF.inc'
      include 'd_cleanup.inc'
      RETURN
      END

      SUBROUTINE GETFLOWMBERR(ERR)
C *** GET TOTAL AND RATE FLOW MASS BALANCE ERRORS AND RETURN IN ERR
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/MASSB/ BL(72),bcmft,bcmtt,bl29I,bl29IT,bl29O,bl29OT,
     1bl68I,bl68IT,bl68o,bl68OT,bl66T
c      include 'c_scon.inc'
      common/massb1/ bltemp36,bltemp39,bltemp42,bltemp45,bcmf,bcmt,
     1bltemp60
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      DIMENSION ERR(2)
      IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
      END IF
      FMB1 = BL(13)
      FMB2 = BL(16) + BL(25)
      FMB3 = bl29IT
      FMB4 = bl29OT
      FMB5 = BL(15)
      FMB6 = BL(18) + BL(27)
      FMB7 = bl29I/DELT
      FMB8 = bl29O/DELT
      E1 = FMB1 - FMB4
      E2 = -FMB2 + FMB3
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
      ELSE
        ERR(1) = 0
      END IF
      E1 = FMB5 - FMB8
      E2 = -FMB6 + FMB7
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
      ELSE
        ERR(2) = 0
      END IF
      RETURN
      END

      SUBROUTINE GETTRANSMBERR(ERR)
C *** GET TOTAL AND RATE CHEMICAL MASS BALANCE ERRORS AND RETURN IN ERR
      include 'd_scon.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_scon.inc'
      COMMON/MASSB/ BL(72),bcmft,bcmtt,bl29I,bl29IT,bl29O,bl29OT,
     1bl68I,bl68IT,bl68o,bl68OT,bl66T
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP
      common/massb1/ bltemp36,bltemp39,bltemp42,bltemp45,bcmf,bcmt,
     1bltemp60
      DIMENSION ERR(2)
      IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
      END IF
      TMB1 = BL(52)
      TMB2 = BL(55)+BL(58)+BL(61)+bl66T
      TMB3 = bl68IT
      TMB4 = bl68OT
      TMB5 = BL(54)
      TMB6 = BL(57)+BL(60)+BL(63)+BL(66)
      TMB7 = bl68I/DELT
      TMB8 = bl68O/DELT
      E1 = TMB1 - TMB4
      E2 = -TMB2 + TMB3
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
      ELSE
        ERR(1) = 0
      END IF
      E1 = TMB5 - TMB8
      E2 = -TMB6 + TMB7
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
      ELSE
        ERR(2) = 0
      END IF
      RETURN
      END

      SUBROUTINE GETVX(VELX, NN)
C *** GET THE X VELOCITY AND RETURN IT IN VELX, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_kcon.inc'
      include 'd_trxx.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_kcon.inc'
c      include 'c_trxx.inc'
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      DIMENSION VELX(NN)
      IF(.NOT.TRANS) CALL VTVELO
      DO 70 J=1,NLY
        DO 70 N=1,NXR
          IN=NLY*(N-1)+J
          IF(HX(IN).EQ.0.0D0) THEN
            VELX(IN)=0.0D0
          ELSE
            VELX(IN)=(VX(IN)+VX(IN+NLY))/2
          END IF
   70 CONTINUE
      RETURN
      END

      SUBROUTINE GETVZ(VELZ, NN)
C *** GET THE Z VELOCITY AND RETURN IT IN VELZ, WHICH IS PROVIDED
C *** BY THE CALLING PROGRAM
      include 'd_kcon.inc'
      include 'd_trxx.inc'
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
c      include 'c_kcon.inc'
c      include 'c_trxx.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES
      DIMENSION VELZ(NN)
      DO 70 J=1,NLY
        DO 70 N=1,NXR
          IN=NLY*(N-1)+J
          IF(HX(IN).EQ.0.0D0) THEN
            VELZ(IN)=0.0D0
          ELSE
            VELZ(IN)=(VZ(IN)+VZ(IN+1))/2
          END IF
   70 CONTINUE
      RETURN
      END

      SUBROUTINE DOTRANS(IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      LOGICAL TRANS,TRANS1,SORP,SSTATE
      COMMON/TRXY/EPS1,TRANS,TRANS1,SORP,SSTATE,MB9(72),NMB9
      IF (TRANS) THEN
        IFLAG=1
      ELSE
        IFLAG=0
      ENDIF
      RETURN
      END
